// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/proto/mumble.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Version {
    // message fields
    version: ::std::option::Option<u32>,
    release: ::protobuf::SingularField<::std::string::String>,
    os: ::protobuf::SingularField<::std::string::String>,
    os_version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as ::protobuf::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string release = 2;


    pub fn get_release(&self) -> &str {
        match self.release.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_release(&mut self) {
        self.release.clear();
    }

    pub fn has_release(&self) -> bool {
        self.release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: ::std::string::String) {
        self.release = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release(&mut self) -> &mut ::std::string::String {
        if self.release.is_none() {
            self.release.set_default();
        }
        self.release.as_mut().unwrap()
    }

    // Take field
    pub fn take_release(&mut self) -> ::std::string::String {
        self.release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os = 3;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os_version = 4;


    pub fn get_os_version(&self) -> &str {
        match self.os_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os_version(&mut self) {
        self.os_version.clear();
    }

    pub fn has_os_version(&self) -> bool {
        self.os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version(&mut self) -> &mut ::std::string::String {
        if self.os_version.is_none() {
            self.os_version.set_default();
        }
        self.os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        self.os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Version {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.release)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.release.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.os_version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.release.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.os_version.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Version {
        Version::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &Version| { &m.version },
                |m: &mut Version| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "release",
                |m: &Version| { &m.release },
                |m: &mut Version| { &mut m.release },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &Version| { &m.os },
                |m: &mut Version| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_version",
                |m: &Version| { &m.os_version },
                |m: &mut Version| { &mut m.os_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Version>(
                "Version",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Version {
        static instance: ::protobuf::rt::LazyV2<Version> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Version::new)
    }
}

impl ::protobuf::Clear for Version {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.release.clear();
        self.os.clear();
        self.os_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UDPTunnel {
    // message fields
    packet: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UDPTunnel {
    fn default() -> &'a UDPTunnel {
        <UDPTunnel as ::protobuf::Message>::default_instance()
    }
}

impl UDPTunnel {
    pub fn new() -> UDPTunnel {
        ::std::default::Default::default()
    }

    // required bytes packet = 1;


    pub fn get_packet(&self) -> &[u8] {
        match self.packet.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: ::std::vec::Vec<u8>) {
        self.packet = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packet.is_none() {
            self.packet.set_default();
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> ::std::vec::Vec<u8> {
        self.packet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UDPTunnel {
    fn is_initialized(&self) -> bool {
        if self.packet.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UDPTunnel {
        UDPTunnel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packet",
                |m: &UDPTunnel| { &m.packet },
                |m: &mut UDPTunnel| { &mut m.packet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UDPTunnel>(
                "UDPTunnel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UDPTunnel {
        static instance: ::protobuf::rt::LazyV2<UDPTunnel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UDPTunnel::new)
    }
}

impl ::protobuf::Clear for UDPTunnel {
    fn clear(&mut self) {
        self.packet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UDPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UDPTunnel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticate {
    // message fields
    username: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    pub tokens: ::protobuf::RepeatedField<::std::string::String>,
    pub celt_versions: ::std::vec::Vec<i32>,
    opus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticate {
    fn default() -> &'a Authenticate {
        <Authenticate as ::protobuf::Message>::default_instance()
    }
}

impl Authenticate {
    pub fn new() -> Authenticate {
        ::std::default::Default::default()
    }

    // optional string username = 1;


    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 2;


    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tokens = 3;


    pub fn get_tokens(&self) -> &[::std::string::String] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    // repeated int32 celt_versions = 4;


    pub fn get_celt_versions(&self) -> &[i32] {
        &self.celt_versions
    }
    pub fn clear_celt_versions(&mut self) {
        self.celt_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_celt_versions(&mut self, v: ::std::vec::Vec<i32>) {
        self.celt_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_celt_versions(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.celt_versions
    }

    // Take field
    pub fn take_celt_versions(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.celt_versions, ::std::vec::Vec::new())
    }

    // optional bool opus = 5;


    pub fn get_opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }
    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Authenticate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tokens)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.celt_versions)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.celt_versions {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.opus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.tokens {
            os.write_string(3, &v)?;
        };
        for v in &self.celt_versions {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.opus {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticate {
        Authenticate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &Authenticate| { &m.username },
                |m: &mut Authenticate| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &Authenticate| { &m.password },
                |m: &mut Authenticate| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tokens",
                |m: &Authenticate| { &m.tokens },
                |m: &mut Authenticate| { &mut m.tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "celt_versions",
                |m: &Authenticate| { &m.celt_versions },
                |m: &mut Authenticate| { &mut m.celt_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "opus",
                |m: &Authenticate| { &m.opus },
                |m: &mut Authenticate| { &mut m.opus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticate>(
                "Authenticate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticate {
        static instance: ::protobuf::rt::LazyV2<Authenticate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticate::new)
    }
}

impl ::protobuf::Clear for Authenticate {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.tokens.clear();
        self.celt_versions.clear();
        self.opus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    timestamp: ::std::option::Option<u64>,
    good: ::std::option::Option<u32>,
    late: ::std::option::Option<u32>,
    lost: ::std::option::Option<u32>,
    resync: ::std::option::Option<u32>,
    udp_packets: ::std::option::Option<u32>,
    tcp_packets: ::std::option::Option<u32>,
    udp_ping_avg: ::std::option::Option<f32>,
    udp_ping_var: ::std::option::Option<f32>,
    tcp_ping_avg: ::std::option::Option<f32>,
    tcp_ping_var: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 good = 2;


    pub fn get_good(&self) -> u32 {
        self.good.unwrap_or(0)
    }
    pub fn clear_good(&mut self) {
        self.good = ::std::option::Option::None;
    }

    pub fn has_good(&self) -> bool {
        self.good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good(&mut self, v: u32) {
        self.good = ::std::option::Option::Some(v);
    }

    // optional uint32 late = 3;


    pub fn get_late(&self) -> u32 {
        self.late.unwrap_or(0)
    }
    pub fn clear_late(&mut self) {
        self.late = ::std::option::Option::None;
    }

    pub fn has_late(&self) -> bool {
        self.late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late(&mut self, v: u32) {
        self.late = ::std::option::Option::Some(v);
    }

    // optional uint32 lost = 4;


    pub fn get_lost(&self) -> u32 {
        self.lost.unwrap_or(0)
    }
    pub fn clear_lost(&mut self) {
        self.lost = ::std::option::Option::None;
    }

    pub fn has_lost(&self) -> bool {
        self.lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lost(&mut self, v: u32) {
        self.lost = ::std::option::Option::Some(v);
    }

    // optional uint32 resync = 5;


    pub fn get_resync(&self) -> u32 {
        self.resync.unwrap_or(0)
    }
    pub fn clear_resync(&mut self) {
        self.resync = ::std::option::Option::None;
    }

    pub fn has_resync(&self) -> bool {
        self.resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resync(&mut self, v: u32) {
        self.resync = ::std::option::Option::Some(v);
    }

    // optional uint32 udp_packets = 6;


    pub fn get_udp_packets(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }
    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_packets = 7;


    pub fn get_tcp_packets(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }
    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_avg = 8;


    pub fn get_udp_ping_avg(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }
    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_var = 9;


    pub fn get_udp_ping_var(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }
    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_avg = 10;


    pub fn get_tcp_ping_avg(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }
    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_var = 11;


    pub fn get_tcp_ping_var(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }
    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.good = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.late = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lost = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resync = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.udp_packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcp_packets = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.udp_ping_avg = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.udp_ping_var = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tcp_ping_avg = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tcp_ping_var = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.good {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.late {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lost {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resync {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.udp_packets {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcp_packets {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.udp_ping_avg {
            my_size += 5;
        }
        if let Some(v) = self.udp_ping_var {
            my_size += 5;
        }
        if let Some(v) = self.tcp_ping_avg {
            my_size += 5;
        }
        if let Some(v) = self.tcp_ping_var {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.good {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.late {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.lost {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.resync {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.udp_packets {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tcp_packets {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.udp_ping_avg {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.udp_ping_var {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.tcp_ping_avg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.tcp_ping_var {
            os.write_float(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Ping| { &m.timestamp },
                |m: &mut Ping| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "good",
                |m: &Ping| { &m.good },
                |m: &mut Ping| { &mut m.good },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "late",
                |m: &Ping| { &m.late },
                |m: &mut Ping| { &mut m.late },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lost",
                |m: &Ping| { &m.lost },
                |m: &mut Ping| { &mut m.lost },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resync",
                |m: &Ping| { &m.resync },
                |m: &mut Ping| { &mut m.resync },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "udp_packets",
                |m: &Ping| { &m.udp_packets },
                |m: &mut Ping| { &mut m.udp_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcp_packets",
                |m: &Ping| { &m.tcp_packets },
                |m: &mut Ping| { &mut m.tcp_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "udp_ping_avg",
                |m: &Ping| { &m.udp_ping_avg },
                |m: &mut Ping| { &mut m.udp_ping_avg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "udp_ping_var",
                |m: &Ping| { &m.udp_ping_var },
                |m: &mut Ping| { &mut m.udp_ping_var },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tcp_ping_avg",
                |m: &Ping| { &m.tcp_ping_avg },
                |m: &mut Ping| { &mut m.tcp_ping_avg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tcp_ping_var",
                |m: &Ping| { &m.tcp_ping_var },
                |m: &mut Ping| { &mut m.tcp_ping_var },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.good = ::std::option::Option::None;
        self.late = ::std::option::Option::None;
        self.lost = ::std::option::Option::None;
        self.resync = ::std::option::Option::None;
        self.udp_packets = ::std::option::Option::None;
        self.tcp_packets = ::std::option::Option::None;
        self.udp_ping_avg = ::std::option::Option::None;
        self.udp_ping_var = ::std::option::Option::None;
        self.tcp_ping_avg = ::std::option::Option::None;
        self.tcp_ping_var = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reject {
    // message fields
    field_type: ::std::option::Option<Reject_RejectType>,
    reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reject {
    fn default() -> &'a Reject {
        <Reject as ::protobuf::Message>::default_instance()
    }
}

impl Reject {
    pub fn new() -> Reject {
        ::std::default::Default::default()
    }

    // optional .MumbleProto.Reject.RejectType type = 1;


    pub fn get_field_type(&self) -> Reject_RejectType {
        self.field_type.unwrap_or(Reject_RejectType::None)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Reject_RejectType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Reject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reject {
        Reject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Reject_RejectType>>(
                "type",
                |m: &Reject| { &m.field_type },
                |m: &mut Reject| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &Reject| { &m.reason },
                |m: &mut Reject| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Reject>(
                "Reject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Reject {
        static instance: ::protobuf::rt::LazyV2<Reject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reject::new)
    }
}

impl ::protobuf::Clear for Reject {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Reject_RejectType {
    None = 0,
    WrongVersion = 1,
    InvalidUsername = 2,
    WrongUserPW = 3,
    WrongServerPW = 4,
    UsernameInUse = 5,
    ServerFull = 6,
    NoCertificate = 7,
    AuthenticatorFail = 8,
}

impl ::protobuf::ProtobufEnum for Reject_RejectType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Reject_RejectType> {
        match value {
            0 => ::std::option::Option::Some(Reject_RejectType::None),
            1 => ::std::option::Option::Some(Reject_RejectType::WrongVersion),
            2 => ::std::option::Option::Some(Reject_RejectType::InvalidUsername),
            3 => ::std::option::Option::Some(Reject_RejectType::WrongUserPW),
            4 => ::std::option::Option::Some(Reject_RejectType::WrongServerPW),
            5 => ::std::option::Option::Some(Reject_RejectType::UsernameInUse),
            6 => ::std::option::Option::Some(Reject_RejectType::ServerFull),
            7 => ::std::option::Option::Some(Reject_RejectType::NoCertificate),
            8 => ::std::option::Option::Some(Reject_RejectType::AuthenticatorFail),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Reject_RejectType] = &[
            Reject_RejectType::None,
            Reject_RejectType::WrongVersion,
            Reject_RejectType::InvalidUsername,
            Reject_RejectType::WrongUserPW,
            Reject_RejectType::WrongServerPW,
            Reject_RejectType::UsernameInUse,
            Reject_RejectType::ServerFull,
            Reject_RejectType::NoCertificate,
            Reject_RejectType::AuthenticatorFail,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Reject_RejectType>("Reject.RejectType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Reject_RejectType {
}

impl ::std::default::Default for Reject_RejectType {
    fn default() -> Self {
        Reject_RejectType::None
    }
}

impl ::protobuf::reflect::ProtobufValue for Reject_RejectType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerSync {
    // message fields
    session: ::std::option::Option<u32>,
    max_bandwidth: ::std::option::Option<u32>,
    welcome_text: ::protobuf::SingularField<::std::string::String>,
    permissions: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerSync {
    fn default() -> &'a ServerSync {
        <ServerSync as ::protobuf::Message>::default_instance()
    }
}

impl ServerSync {
    pub fn new() -> ServerSync {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 max_bandwidth = 2;


    pub fn get_max_bandwidth(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }
    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    // optional string welcome_text = 3;


    pub fn get_welcome_text(&self) -> &str {
        match self.welcome_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_welcome_text(&mut self) {
        self.welcome_text.clear();
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text(&mut self) -> &mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text.set_default();
        }
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 permissions = 4;


    pub fn get_permissions(&self) -> u64 {
        self.permissions.unwrap_or(0)
    }
    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u64) {
        self.permissions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_bandwidth = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.welcome_text)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.permissions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_bandwidth {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.welcome_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_bandwidth {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.welcome_text.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerSync {
        ServerSync::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &ServerSync| { &m.session },
                |m: &mut ServerSync| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_bandwidth",
                |m: &ServerSync| { &m.max_bandwidth },
                |m: &mut ServerSync| { &mut m.max_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "welcome_text",
                |m: &ServerSync| { &m.welcome_text },
                |m: &mut ServerSync| { &mut m.welcome_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "permissions",
                |m: &ServerSync| { &m.permissions },
                |m: &mut ServerSync| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerSync>(
                "ServerSync",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerSync {
        static instance: ::protobuf::rt::LazyV2<ServerSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerSync::new)
    }
}

impl ::protobuf::Clear for ServerSync {
    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.max_bandwidth = ::std::option::Option::None;
        self.welcome_text.clear();
        self.permissions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelRemove {
    // message fields
    channel_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelRemove {
    fn default() -> &'a ChannelRemove {
        <ChannelRemove as ::protobuf::Message>::default_instance()
    }
}

impl ChannelRemove {
    pub fn new() -> ChannelRemove {
        ::std::default::Default::default()
    }

    // required uint32 channel_id = 1;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChannelRemove {
    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelRemove {
        ChannelRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &ChannelRemove| { &m.channel_id },
                |m: &mut ChannelRemove| { &mut m.channel_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelRemove>(
                "ChannelRemove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelRemove {
        static instance: ::protobuf::rt::LazyV2<ChannelRemove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelRemove::new)
    }
}

impl ::protobuf::Clear for ChannelRemove {
    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelState {
    // message fields
    channel_id: ::std::option::Option<u32>,
    parent: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub links: ::std::vec::Vec<u32>,
    description: ::protobuf::SingularField<::std::string::String>,
    pub links_add: ::std::vec::Vec<u32>,
    pub links_remove: ::std::vec::Vec<u32>,
    temporary: ::std::option::Option<bool>,
    position: ::std::option::Option<i32>,
    description_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    max_users: ::std::option::Option<u32>,
    is_enter_restricted: ::std::option::Option<bool>,
    can_enter: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelState {
    fn default() -> &'a ChannelState {
        <ChannelState as ::protobuf::Message>::default_instance()
    }
}

impl ChannelState {
    pub fn new() -> ChannelState {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent = 2;


    pub fn get_parent(&self) -> u32 {
        self.parent.unwrap_or(0)
    }
    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: u32) {
        self.parent = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 links = 4;


    pub fn get_links(&self) -> &[u32] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::vec::Vec<u32>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links, ::std::vec::Vec::new())
    }

    // optional string description = 5;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 links_add = 6;


    pub fn get_links_add(&self) -> &[u32] {
        &self.links_add
    }
    pub fn clear_links_add(&mut self) {
        self.links_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_links_add(&mut self, v: ::std::vec::Vec<u32>) {
        self.links_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links_add(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.links_add
    }

    // Take field
    pub fn take_links_add(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links_add, ::std::vec::Vec::new())
    }

    // repeated uint32 links_remove = 7;


    pub fn get_links_remove(&self) -> &[u32] {
        &self.links_remove
    }
    pub fn clear_links_remove(&mut self) {
        self.links_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_links_remove(&mut self, v: ::std::vec::Vec<u32>) {
        self.links_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links_remove(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.links_remove
    }

    // Take field
    pub fn take_links_remove(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links_remove, ::std::vec::Vec::new())
    }

    // optional bool temporary = 8;


    pub fn get_temporary(&self) -> bool {
        self.temporary.unwrap_or(false)
    }
    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }

    // optional int32 position = 9;


    pub fn get_position(&self) -> i32 {
        self.position.unwrap_or(0i32)
    }
    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional bytes description_hash = 10;


    pub fn get_description_hash(&self) -> &[u8] {
        match self.description_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    pub fn has_description_hash(&self) -> bool {
        self.description_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.description_hash.is_none() {
            self.description_hash.set_default();
        }
        self.description_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.description_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 max_users = 11;


    pub fn get_max_users(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }
    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    // optional bool is_enter_restricted = 12;


    pub fn get_is_enter_restricted(&self) -> bool {
        self.is_enter_restricted.unwrap_or(false)
    }
    pub fn clear_is_enter_restricted(&mut self) {
        self.is_enter_restricted = ::std::option::Option::None;
    }

    pub fn has_is_enter_restricted(&self) -> bool {
        self.is_enter_restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enter_restricted(&mut self, v: bool) {
        self.is_enter_restricted = ::std::option::Option::Some(v);
    }

    // optional bool can_enter = 13;


    pub fn get_can_enter(&self) -> bool {
        self.can_enter.unwrap_or(false)
    }
    pub fn clear_can_enter(&mut self) {
        self.can_enter = ::std::option::Option::None;
    }

    pub fn has_can_enter(&self) -> bool {
        self.can_enter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_enter(&mut self, v: bool) {
        self.can_enter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChannelState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links_add)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links_remove)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temporary = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.position = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.description_hash)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_users = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enter_restricted = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_enter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.links {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.links_add {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.links_remove {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.temporary {
            my_size += 2;
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.description_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.max_users {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_enter_restricted {
            my_size += 2;
        }
        if let Some(v) = self.can_enter {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.parent {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.links {
            os.write_uint32(4, *v)?;
        };
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.links_add {
            os.write_uint32(6, *v)?;
        };
        for v in &self.links_remove {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.temporary {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.position {
            os.write_int32(9, v)?;
        }
        if let Some(ref v) = self.description_hash.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(v) = self.max_users {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_enter_restricted {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.can_enter {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelState {
        ChannelState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &ChannelState| { &m.channel_id },
                |m: &mut ChannelState| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "parent",
                |m: &ChannelState| { &m.parent },
                |m: &mut ChannelState| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ChannelState| { &m.name },
                |m: &mut ChannelState| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "links",
                |m: &ChannelState| { &m.links },
                |m: &mut ChannelState| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ChannelState| { &m.description },
                |m: &mut ChannelState| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "links_add",
                |m: &ChannelState| { &m.links_add },
                |m: &mut ChannelState| { &mut m.links_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "links_remove",
                |m: &ChannelState| { &m.links_remove },
                |m: &mut ChannelState| { &mut m.links_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "temporary",
                |m: &ChannelState| { &m.temporary },
                |m: &mut ChannelState| { &mut m.temporary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "position",
                |m: &ChannelState| { &m.position },
                |m: &mut ChannelState| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description_hash",
                |m: &ChannelState| { &m.description_hash },
                |m: &mut ChannelState| { &mut m.description_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_users",
                |m: &ChannelState| { &m.max_users },
                |m: &mut ChannelState| { &mut m.max_users },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_enter_restricted",
                |m: &ChannelState| { &m.is_enter_restricted },
                |m: &mut ChannelState| { &mut m.is_enter_restricted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_enter",
                |m: &ChannelState| { &m.can_enter },
                |m: &mut ChannelState| { &mut m.can_enter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelState>(
                "ChannelState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelState {
        static instance: ::protobuf::rt::LazyV2<ChannelState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelState::new)
    }
}

impl ::protobuf::Clear for ChannelState {
    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.name.clear();
        self.links.clear();
        self.description.clear();
        self.links_add.clear();
        self.links_remove.clear();
        self.temporary = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.description_hash.clear();
        self.max_users = ::std::option::Option::None;
        self.is_enter_restricted = ::std::option::Option::None;
        self.can_enter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserRemove {
    // message fields
    session: ::std::option::Option<u32>,
    actor: ::std::option::Option<u32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    ban: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserRemove {
    fn default() -> &'a UserRemove {
        <UserRemove as ::protobuf::Message>::default_instance()
    }
}

impl UserRemove {
    pub fn new() -> UserRemove {
        ::std::default::Default::default()
    }

    // required uint32 session = 1;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 actor = 2;


    pub fn get_actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }
    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool ban = 4;


    pub fn get_ban(&self) -> bool {
        self.ban.unwrap_or(false)
    }
    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserRemove {
    fn is_initialized(&self) -> bool {
        if self.session.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ban = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ban {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actor {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ban {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserRemove {
        UserRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &UserRemove| { &m.session },
                |m: &mut UserRemove| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "actor",
                |m: &UserRemove| { &m.actor },
                |m: &mut UserRemove| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &UserRemove| { &m.reason },
                |m: &mut UserRemove| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ban",
                |m: &UserRemove| { &m.ban },
                |m: &mut UserRemove| { &mut m.ban },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserRemove>(
                "UserRemove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserRemove {
        static instance: ::protobuf::rt::LazyV2<UserRemove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserRemove::new)
    }
}

impl ::protobuf::Clear for UserRemove {
    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.actor = ::std::option::Option::None;
        self.reason.clear();
        self.ban = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserState {
    // message fields
    session: ::std::option::Option<u32>,
    actor: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    user_id: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    mute: ::std::option::Option<bool>,
    deaf: ::std::option::Option<bool>,
    suppress: ::std::option::Option<bool>,
    self_mute: ::std::option::Option<bool>,
    self_deaf: ::std::option::Option<bool>,
    texture: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    plugin_context: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    plugin_identity: ::protobuf::SingularField<::std::string::String>,
    comment: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    comment_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    texture_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    priority_speaker: ::std::option::Option<bool>,
    recording: ::std::option::Option<bool>,
    pub temporary_access_tokens: ::protobuf::RepeatedField<::std::string::String>,
    pub listening_channel_add: ::std::vec::Vec<u32>,
    pub listening_channel_remove: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserState {
    fn default() -> &'a UserState {
        <UserState as ::protobuf::Message>::default_instance()
    }
}

impl UserState {
    pub fn new() -> UserState {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 actor = 2;


    pub fn get_actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }
    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 user_id = 4;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 5;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional bool mute = 6;


    pub fn get_mute(&self) -> bool {
        self.mute.unwrap_or(false)
    }
    pub fn clear_mute(&mut self) {
        self.mute = ::std::option::Option::None;
    }

    pub fn has_mute(&self) -> bool {
        self.mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute(&mut self, v: bool) {
        self.mute = ::std::option::Option::Some(v);
    }

    // optional bool deaf = 7;


    pub fn get_deaf(&self) -> bool {
        self.deaf.unwrap_or(false)
    }
    pub fn clear_deaf(&mut self) {
        self.deaf = ::std::option::Option::None;
    }

    pub fn has_deaf(&self) -> bool {
        self.deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaf(&mut self, v: bool) {
        self.deaf = ::std::option::Option::Some(v);
    }

    // optional bool suppress = 8;


    pub fn get_suppress(&self) -> bool {
        self.suppress.unwrap_or(false)
    }
    pub fn clear_suppress(&mut self) {
        self.suppress = ::std::option::Option::None;
    }

    pub fn has_suppress(&self) -> bool {
        self.suppress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress(&mut self, v: bool) {
        self.suppress = ::std::option::Option::Some(v);
    }

    // optional bool self_mute = 9;


    pub fn get_self_mute(&self) -> bool {
        self.self_mute.unwrap_or(false)
    }
    pub fn clear_self_mute(&mut self) {
        self.self_mute = ::std::option::Option::None;
    }

    pub fn has_self_mute(&self) -> bool {
        self.self_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_mute(&mut self, v: bool) {
        self.self_mute = ::std::option::Option::Some(v);
    }

    // optional bool self_deaf = 10;


    pub fn get_self_deaf(&self) -> bool {
        self.self_deaf.unwrap_or(false)
    }
    pub fn clear_self_deaf(&mut self) {
        self.self_deaf = ::std::option::Option::None;
    }

    pub fn has_self_deaf(&self) -> bool {
        self.self_deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_deaf(&mut self, v: bool) {
        self.self_deaf = ::std::option::Option::Some(v);
    }

    // optional bytes texture = 11;


    pub fn get_texture(&self) -> &[u8] {
        match self.texture.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_texture(&mut self) {
        self.texture.clear();
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture.is_none() {
            self.texture.set_default();
        }
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> ::std::vec::Vec<u8> {
        self.texture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes plugin_context = 12;


    pub fn get_plugin_context(&self) -> &[u8] {
        match self.plugin_context.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_plugin_context(&mut self) {
        self.plugin_context.clear();
    }

    pub fn has_plugin_context(&self) -> bool {
        self.plugin_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.plugin_context = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_context(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.plugin_context.is_none() {
            self.plugin_context.set_default();
        }
        self.plugin_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_context(&mut self) -> ::std::vec::Vec<u8> {
        self.plugin_context.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string plugin_identity = 13;


    pub fn get_plugin_identity(&self) -> &str {
        match self.plugin_identity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_plugin_identity(&mut self) {
        self.plugin_identity.clear();
    }

    pub fn has_plugin_identity(&self) -> bool {
        self.plugin_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_identity(&mut self, v: ::std::string::String) {
        self.plugin_identity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_identity(&mut self) -> &mut ::std::string::String {
        if self.plugin_identity.is_none() {
            self.plugin_identity.set_default();
        }
        self.plugin_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_identity(&mut self) -> ::std::string::String {
        self.plugin_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string comment = 14;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hash = 15;


    pub fn get_hash(&self) -> &str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes comment_hash = 16;


    pub fn get_comment_hash(&self) -> &[u8] {
        match self.comment_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_comment_hash(&mut self) {
        self.comment_hash.clear();
    }

    pub fn has_comment_hash(&self) -> bool {
        self.comment_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.comment_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.comment_hash.is_none() {
            self.comment_hash.set_default();
        }
        self.comment_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.comment_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes texture_hash = 17;


    pub fn get_texture_hash(&self) -> &[u8] {
        match self.texture_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_texture_hash(&mut self) {
        self.texture_hash.clear();
    }

    pub fn has_texture_hash(&self) -> bool {
        self.texture_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture_hash.is_none() {
            self.texture_hash.set_default();
        }
        self.texture_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.texture_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool priority_speaker = 18;


    pub fn get_priority_speaker(&self) -> bool {
        self.priority_speaker.unwrap_or(false)
    }
    pub fn clear_priority_speaker(&mut self) {
        self.priority_speaker = ::std::option::Option::None;
    }

    pub fn has_priority_speaker(&self) -> bool {
        self.priority_speaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_speaker(&mut self, v: bool) {
        self.priority_speaker = ::std::option::Option::Some(v);
    }

    // optional bool recording = 19;


    pub fn get_recording(&self) -> bool {
        self.recording.unwrap_or(false)
    }
    pub fn clear_recording(&mut self) {
        self.recording = ::std::option::Option::None;
    }

    pub fn has_recording(&self) -> bool {
        self.recording.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording(&mut self, v: bool) {
        self.recording = ::std::option::Option::Some(v);
    }

    // repeated string temporary_access_tokens = 20;


    pub fn get_temporary_access_tokens(&self) -> &[::std::string::String] {
        &self.temporary_access_tokens
    }
    pub fn clear_temporary_access_tokens(&mut self) {
        self.temporary_access_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_temporary_access_tokens(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.temporary_access_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_temporary_access_tokens(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.temporary_access_tokens
    }

    // Take field
    pub fn take_temporary_access_tokens(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.temporary_access_tokens, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 listening_channel_add = 21;


    pub fn get_listening_channel_add(&self) -> &[u32] {
        &self.listening_channel_add
    }
    pub fn clear_listening_channel_add(&mut self) {
        self.listening_channel_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_listening_channel_add(&mut self, v: ::std::vec::Vec<u32>) {
        self.listening_channel_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listening_channel_add(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.listening_channel_add
    }

    // Take field
    pub fn take_listening_channel_add(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.listening_channel_add, ::std::vec::Vec::new())
    }

    // repeated uint32 listening_channel_remove = 22;


    pub fn get_listening_channel_remove(&self) -> &[u32] {
        &self.listening_channel_remove
    }
    pub fn clear_listening_channel_remove(&mut self) {
        self.listening_channel_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_listening_channel_remove(&mut self, v: ::std::vec::Vec<u32>) {
        self.listening_channel_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listening_channel_remove(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.listening_channel_remove
    }

    // Take field
    pub fn take_listening_channel_remove(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.listening_channel_remove, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UserState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mute = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deaf = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppress = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.self_mute = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.self_deaf = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.plugin_context)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.plugin_identity)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.comment_hash)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture_hash)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.priority_speaker = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recording = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.temporary_access_tokens)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.listening_channel_add)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.listening_channel_remove)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mute {
            my_size += 2;
        }
        if let Some(v) = self.deaf {
            my_size += 2;
        }
        if let Some(v) = self.suppress {
            my_size += 2;
        }
        if let Some(v) = self.self_mute {
            my_size += 2;
        }
        if let Some(v) = self.self_deaf {
            my_size += 2;
        }
        if let Some(ref v) = self.texture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(ref v) = self.plugin_context.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(ref v) = self.plugin_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.comment_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(ref v) = self.texture_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(17, &v);
        }
        if let Some(v) = self.priority_speaker {
            my_size += 3;
        }
        if let Some(v) = self.recording {
            my_size += 3;
        }
        for value in &self.temporary_access_tokens {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.listening_channel_add {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.listening_channel_remove {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actor {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.user_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mute {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.deaf {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.suppress {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.self_mute {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.self_deaf {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.texture.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(ref v) = self.plugin_context.as_ref() {
            os.write_bytes(12, &v)?;
        }
        if let Some(ref v) = self.plugin_identity.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.comment_hash.as_ref() {
            os.write_bytes(16, &v)?;
        }
        if let Some(ref v) = self.texture_hash.as_ref() {
            os.write_bytes(17, &v)?;
        }
        if let Some(v) = self.priority_speaker {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.recording {
            os.write_bool(19, v)?;
        }
        for v in &self.temporary_access_tokens {
            os.write_string(20, &v)?;
        };
        for v in &self.listening_channel_add {
            os.write_uint32(21, *v)?;
        };
        for v in &self.listening_channel_remove {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserState {
        UserState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &UserState| { &m.session },
                |m: &mut UserState| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "actor",
                |m: &UserState| { &m.actor },
                |m: &mut UserState| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserState| { &m.name },
                |m: &mut UserState| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_id",
                |m: &UserState| { &m.user_id },
                |m: &mut UserState| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &UserState| { &m.channel_id },
                |m: &mut UserState| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mute",
                |m: &UserState| { &m.mute },
                |m: &mut UserState| { &mut m.mute },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deaf",
                |m: &UserState| { &m.deaf },
                |m: &mut UserState| { &mut m.deaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "suppress",
                |m: &UserState| { &m.suppress },
                |m: &mut UserState| { &mut m.suppress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "self_mute",
                |m: &UserState| { &m.self_mute },
                |m: &mut UserState| { &mut m.self_mute },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "self_deaf",
                |m: &UserState| { &m.self_deaf },
                |m: &mut UserState| { &mut m.self_deaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "texture",
                |m: &UserState| { &m.texture },
                |m: &mut UserState| { &mut m.texture },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "plugin_context",
                |m: &UserState| { &m.plugin_context },
                |m: &mut UserState| { &mut m.plugin_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plugin_identity",
                |m: &UserState| { &m.plugin_identity },
                |m: &mut UserState| { &mut m.plugin_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &UserState| { &m.comment },
                |m: &mut UserState| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &UserState| { &m.hash },
                |m: &mut UserState| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "comment_hash",
                |m: &UserState| { &m.comment_hash },
                |m: &mut UserState| { &mut m.comment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "texture_hash",
                |m: &UserState| { &m.texture_hash },
                |m: &mut UserState| { &mut m.texture_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "priority_speaker",
                |m: &UserState| { &m.priority_speaker },
                |m: &mut UserState| { &mut m.priority_speaker },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recording",
                |m: &UserState| { &m.recording },
                |m: &mut UserState| { &mut m.recording },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "temporary_access_tokens",
                |m: &UserState| { &m.temporary_access_tokens },
                |m: &mut UserState| { &mut m.temporary_access_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "listening_channel_add",
                |m: &UserState| { &m.listening_channel_add },
                |m: &mut UserState| { &mut m.listening_channel_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "listening_channel_remove",
                |m: &UserState| { &m.listening_channel_remove },
                |m: &mut UserState| { &mut m.listening_channel_remove },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserState>(
                "UserState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserState {
        static instance: ::protobuf::rt::LazyV2<UserState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserState::new)
    }
}

impl ::protobuf::Clear for UserState {
    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.actor = ::std::option::Option::None;
        self.name.clear();
        self.user_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.mute = ::std::option::Option::None;
        self.deaf = ::std::option::Option::None;
        self.suppress = ::std::option::Option::None;
        self.self_mute = ::std::option::Option::None;
        self.self_deaf = ::std::option::Option::None;
        self.texture.clear();
        self.plugin_context.clear();
        self.plugin_identity.clear();
        self.comment.clear();
        self.hash.clear();
        self.comment_hash.clear();
        self.texture_hash.clear();
        self.priority_speaker = ::std::option::Option::None;
        self.recording = ::std::option::Option::None;
        self.temporary_access_tokens.clear();
        self.listening_channel_add.clear();
        self.listening_channel_remove.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BanList {
    // message fields
    pub bans: ::protobuf::RepeatedField<BanList_BanEntry>,
    query: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BanList {
    fn default() -> &'a BanList {
        <BanList as ::protobuf::Message>::default_instance()
    }
}

impl BanList {
    pub fn new() -> BanList {
        ::std::default::Default::default()
    }

    // repeated .MumbleProto.BanList.BanEntry bans = 1;


    pub fn get_bans(&self) -> &[BanList_BanEntry] {
        &self.bans
    }
    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<BanList_BanEntry>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::protobuf::RepeatedField<BanList_BanEntry> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<BanList_BanEntry> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }

    // optional bool query = 2;


    pub fn get_query(&self) -> bool {
        self.query.unwrap_or(false)
    }
    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BanList {
    fn is_initialized(&self) -> bool {
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.query {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bans {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.query {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BanList {
        BanList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BanList_BanEntry>>(
                "bans",
                |m: &BanList| { &m.bans },
                |m: &mut BanList| { &mut m.bans },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "query",
                |m: &BanList| { &m.query },
                |m: &mut BanList| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BanList>(
                "BanList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BanList {
        static instance: ::protobuf::rt::LazyV2<BanList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BanList::new)
    }
}

impl ::protobuf::Clear for BanList {
    fn clear(&mut self) {
        self.bans.clear();
        self.query = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BanList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BanList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BanList_BanEntry {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mask: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    start: ::protobuf::SingularField<::std::string::String>,
    duration: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BanList_BanEntry {
    fn default() -> &'a BanList_BanEntry {
        <BanList_BanEntry as ::protobuf::Message>::default_instance()
    }
}

impl BanList_BanEntry {
    pub fn new() -> BanList_BanEntry {
        ::std::default::Default::default()
    }

    // required bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 mask = 2;


    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }
    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hash = 4;


    pub fn get_hash(&self) -> &str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string start = 6;


    pub fn get_start(&self) -> &str {
        match self.start.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::std::string::String) {
        self.start = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::std::string::String {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::std::string::String {
        self.start.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 duration = 7;


    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BanList_BanEntry {
    fn is_initialized(&self) -> bool {
        if self.address.is_none() {
            return false;
        }
        if self.mask.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.start)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.start.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.mask {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BanList_BanEntry {
        BanList_BanEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &BanList_BanEntry| { &m.address },
                |m: &mut BanList_BanEntry| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mask",
                |m: &BanList_BanEntry| { &m.mask },
                |m: &mut BanList_BanEntry| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BanList_BanEntry| { &m.name },
                |m: &mut BanList_BanEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &BanList_BanEntry| { &m.hash },
                |m: &mut BanList_BanEntry| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &BanList_BanEntry| { &m.reason },
                |m: &mut BanList_BanEntry| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start",
                |m: &BanList_BanEntry| { &m.start },
                |m: &mut BanList_BanEntry| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duration",
                |m: &BanList_BanEntry| { &m.duration },
                |m: &mut BanList_BanEntry| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BanList_BanEntry>(
                "BanList.BanEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BanList_BanEntry {
        static instance: ::protobuf::rt::LazyV2<BanList_BanEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BanList_BanEntry::new)
    }
}

impl ::protobuf::Clear for BanList_BanEntry {
    fn clear(&mut self) {
        self.address.clear();
        self.mask = ::std::option::Option::None;
        self.name.clear();
        self.hash.clear();
        self.reason.clear();
        self.start.clear();
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BanList_BanEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BanList_BanEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextMessage {
    // message fields
    actor: ::std::option::Option<u32>,
    pub session: ::std::vec::Vec<u32>,
    pub channel_id: ::std::vec::Vec<u32>,
    pub tree_id: ::std::vec::Vec<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextMessage {
    fn default() -> &'a TextMessage {
        <TextMessage as ::protobuf::Message>::default_instance()
    }
}

impl TextMessage {
    pub fn new() -> TextMessage {
        ::std::default::Default::default()
    }

    // optional uint32 actor = 1;


    pub fn get_actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }
    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // repeated uint32 session = 2;


    pub fn get_session(&self) -> &[u32] {
        &self.session
    }
    pub fn clear_session(&mut self) {
        self.session.clear();
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::vec::Vec<u32>) {
        self.session = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.session
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session, ::std::vec::Vec::new())
    }

    // repeated uint32 channel_id = 3;


    pub fn get_channel_id(&self) -> &[u32] {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.channel_id, ::std::vec::Vec::new())
    }

    // repeated uint32 tree_id = 4;


    pub fn get_tree_id(&self) -> &[u32] {
        &self.tree_id
    }
    pub fn clear_tree_id(&mut self) {
        self.tree_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.tree_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tree_id
    }

    // Take field
    pub fn take_tree_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tree_id, ::std::vec::Vec::new())
    }

    // required string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TextMessage {
    fn is_initialized(&self) -> bool {
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.actor = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.channel_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tree_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.session {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.channel_id {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tree_id {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actor {
            os.write_uint32(1, v)?;
        }
        for v in &self.session {
            os.write_uint32(2, *v)?;
        };
        for v in &self.channel_id {
            os.write_uint32(3, *v)?;
        };
        for v in &self.tree_id {
            os.write_uint32(4, *v)?;
        };
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextMessage {
        TextMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "actor",
                |m: &TextMessage| { &m.actor },
                |m: &mut TextMessage| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &TextMessage| { &m.session },
                |m: &mut TextMessage| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &TextMessage| { &m.channel_id },
                |m: &mut TextMessage| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tree_id",
                |m: &TextMessage| { &m.tree_id },
                |m: &mut TextMessage| { &mut m.tree_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &TextMessage| { &m.message },
                |m: &mut TextMessage| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextMessage>(
                "TextMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextMessage {
        static instance: ::protobuf::rt::LazyV2<TextMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextMessage::new)
    }
}

impl ::protobuf::Clear for TextMessage {
    fn clear(&mut self) {
        self.actor = ::std::option::Option::None;
        self.session.clear();
        self.channel_id.clear();
        self.tree_id.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PermissionDenied {
    // message fields
    permission: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    session: ::std::option::Option<u32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<PermissionDenied_DenyType>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PermissionDenied {
    fn default() -> &'a PermissionDenied {
        <PermissionDenied as ::protobuf::Message>::default_instance()
    }
}

impl PermissionDenied {
    pub fn new() -> PermissionDenied {
        ::std::default::Default::default()
    }

    // optional uint32 permission = 1;


    pub fn get_permission(&self) -> u32 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 2;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 session = 3;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional string reason = 4;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .MumbleProto.PermissionDenied.DenyType type = 5;


    pub fn get_field_type(&self) -> PermissionDenied_DenyType {
        self.field_type.unwrap_or(PermissionDenied_DenyType::Text)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PermissionDenied_DenyType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string name = 6;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PermissionDenied {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.session {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PermissionDenied {
        PermissionDenied::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "permission",
                |m: &PermissionDenied| { &m.permission },
                |m: &mut PermissionDenied| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &PermissionDenied| { &m.channel_id },
                |m: &mut PermissionDenied| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &PermissionDenied| { &m.session },
                |m: &mut PermissionDenied| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PermissionDenied| { &m.reason },
                |m: &mut PermissionDenied| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PermissionDenied_DenyType>>(
                "type",
                |m: &PermissionDenied| { &m.field_type },
                |m: &mut PermissionDenied| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PermissionDenied| { &m.name },
                |m: &mut PermissionDenied| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PermissionDenied>(
                "PermissionDenied",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PermissionDenied {
        static instance: ::protobuf::rt::LazyV2<PermissionDenied> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PermissionDenied::new)
    }
}

impl ::protobuf::Clear for PermissionDenied {
    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.session = ::std::option::Option::None;
        self.reason.clear();
        self.field_type = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PermissionDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionDenied {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PermissionDenied_DenyType {
    Text = 0,
    Permission = 1,
    SuperUser = 2,
    ChannelName = 3,
    TextTooLong = 4,
    H9K = 5,
    TemporaryChannel = 6,
    MissingCertificate = 7,
    UserName = 8,
    ChannelFull = 9,
    NestingLimit = 10,
    ChannelCountLimit = 11,
    ChannelListenerLimit = 12,
    UserListenerLimit = 13,
}

impl ::protobuf::ProtobufEnum for PermissionDenied_DenyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PermissionDenied_DenyType> {
        match value {
            0 => ::std::option::Option::Some(PermissionDenied_DenyType::Text),
            1 => ::std::option::Option::Some(PermissionDenied_DenyType::Permission),
            2 => ::std::option::Option::Some(PermissionDenied_DenyType::SuperUser),
            3 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelName),
            4 => ::std::option::Option::Some(PermissionDenied_DenyType::TextTooLong),
            5 => ::std::option::Option::Some(PermissionDenied_DenyType::H9K),
            6 => ::std::option::Option::Some(PermissionDenied_DenyType::TemporaryChannel),
            7 => ::std::option::Option::Some(PermissionDenied_DenyType::MissingCertificate),
            8 => ::std::option::Option::Some(PermissionDenied_DenyType::UserName),
            9 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelFull),
            10 => ::std::option::Option::Some(PermissionDenied_DenyType::NestingLimit),
            11 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelCountLimit),
            12 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelListenerLimit),
            13 => ::std::option::Option::Some(PermissionDenied_DenyType::UserListenerLimit),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PermissionDenied_DenyType] = &[
            PermissionDenied_DenyType::Text,
            PermissionDenied_DenyType::Permission,
            PermissionDenied_DenyType::SuperUser,
            PermissionDenied_DenyType::ChannelName,
            PermissionDenied_DenyType::TextTooLong,
            PermissionDenied_DenyType::H9K,
            PermissionDenied_DenyType::TemporaryChannel,
            PermissionDenied_DenyType::MissingCertificate,
            PermissionDenied_DenyType::UserName,
            PermissionDenied_DenyType::ChannelFull,
            PermissionDenied_DenyType::NestingLimit,
            PermissionDenied_DenyType::ChannelCountLimit,
            PermissionDenied_DenyType::ChannelListenerLimit,
            PermissionDenied_DenyType::UserListenerLimit,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PermissionDenied_DenyType>("PermissionDenied.DenyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PermissionDenied_DenyType {
}

impl ::std::default::Default for PermissionDenied_DenyType {
    fn default() -> Self {
        PermissionDenied_DenyType::Text
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionDenied_DenyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL {
    // message fields
    channel_id: ::std::option::Option<u32>,
    inherit_acls: ::std::option::Option<bool>,
    pub groups: ::protobuf::RepeatedField<ACL_ChanGroup>,
    pub acls: ::protobuf::RepeatedField<ACL_ChanACL>,
    query: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL {
    fn default() -> &'a ACL {
        <ACL as ::protobuf::Message>::default_instance()
    }
}

impl ACL {
    pub fn new() -> ACL {
        ::std::default::Default::default()
    }

    // required uint32 channel_id = 1;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional bool inherit_acls = 2;


    pub fn get_inherit_acls(&self) -> bool {
        self.inherit_acls.unwrap_or(true)
    }
    pub fn clear_inherit_acls(&mut self) {
        self.inherit_acls = ::std::option::Option::None;
    }

    pub fn has_inherit_acls(&self) -> bool {
        self.inherit_acls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit_acls(&mut self, v: bool) {
        self.inherit_acls = ::std::option::Option::Some(v);
    }

    // repeated .MumbleProto.ACL.ChanGroup groups = 3;


    pub fn get_groups(&self) -> &[ACL_ChanGroup] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ACL_ChanGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<ACL_ChanGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ACL_ChanGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    // repeated .MumbleProto.ACL.ChanACL acls = 4;


    pub fn get_acls(&self) -> &[ACL_ChanACL] {
        &self.acls
    }
    pub fn clear_acls(&mut self) {
        self.acls.clear();
    }

    // Param is passed by value, moved
    pub fn set_acls(&mut self, v: ::protobuf::RepeatedField<ACL_ChanACL>) {
        self.acls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acls(&mut self) -> &mut ::protobuf::RepeatedField<ACL_ChanACL> {
        &mut self.acls
    }

    // Take field
    pub fn take_acls(&mut self) -> ::protobuf::RepeatedField<ACL_ChanACL> {
        ::std::mem::replace(&mut self.acls, ::protobuf::RepeatedField::new())
    }

    // optional bool query = 5;


    pub fn get_query(&self) -> bool {
        self.query.unwrap_or(false)
    }
    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ACL {
    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        }
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit_acls = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acls)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inherit_acls {
            my_size += 2;
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.acls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.query {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inherit_acls {
            os.write_bool(2, v)?;
        }
        for v in &self.groups {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.acls {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.query {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL {
        ACL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &ACL| { &m.channel_id },
                |m: &mut ACL| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit_acls",
                |m: &ACL| { &m.inherit_acls },
                |m: &mut ACL| { &mut m.inherit_acls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_ChanGroup>>(
                "groups",
                |m: &ACL| { &m.groups },
                |m: &mut ACL| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_ChanACL>>(
                "acls",
                |m: &ACL| { &m.acls },
                |m: &mut ACL| { &mut m.acls },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "query",
                |m: &ACL| { &m.query },
                |m: &mut ACL| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL>(
                "ACL",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL {
        static instance: ::protobuf::rt::LazyV2<ACL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL::new)
    }
}

impl ::protobuf::Clear for ACL {
    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.inherit_acls = ::std::option::Option::None;
        self.groups.clear();
        self.acls.clear();
        self.query = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_ChanGroup {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    inherited: ::std::option::Option<bool>,
    inherit: ::std::option::Option<bool>,
    inheritable: ::std::option::Option<bool>,
    pub add: ::std::vec::Vec<u32>,
    pub remove: ::std::vec::Vec<u32>,
    pub inherited_members: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_ChanGroup {
    fn default() -> &'a ACL_ChanGroup {
        <ACL_ChanGroup as ::protobuf::Message>::default_instance()
    }
}

impl ACL_ChanGroup {
    pub fn new() -> ACL_ChanGroup {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inherited = 2;


    pub fn get_inherited(&self) -> bool {
        self.inherited.unwrap_or(true)
    }
    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    // optional bool inherit = 3;


    pub fn get_inherit(&self) -> bool {
        self.inherit.unwrap_or(true)
    }
    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    // optional bool inheritable = 4;


    pub fn get_inheritable(&self) -> bool {
        self.inheritable.unwrap_or(true)
    }
    pub fn clear_inheritable(&mut self) {
        self.inheritable = ::std::option::Option::None;
    }

    pub fn has_inheritable(&self) -> bool {
        self.inheritable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inheritable(&mut self, v: bool) {
        self.inheritable = ::std::option::Option::Some(v);
    }

    // repeated uint32 add = 5;


    pub fn get_add(&self) -> &[u32] {
        &self.add
    }
    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::std::vec::Vec<u32>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.add, ::std::vec::Vec::new())
    }

    // repeated uint32 remove = 6;


    pub fn get_remove(&self) -> &[u32] {
        &self.remove
    }
    pub fn clear_remove(&mut self) {
        self.remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: ::std::vec::Vec<u32>) {
        self.remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_remove(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.remove
    }

    // Take field
    pub fn take_remove(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.remove, ::std::vec::Vec::new())
    }

    // repeated uint32 inherited_members = 7;


    pub fn get_inherited_members(&self) -> &[u32] {
        &self.inherited_members
    }
    pub fn clear_inherited_members(&mut self) {
        self.inherited_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_inherited_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.inherited_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inherited_members(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.inherited_members
    }

    // Take field
    pub fn take_inherited_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.inherited_members, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ACL_ChanGroup {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inheritable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.add)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.remove)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.inherited_members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inherited {
            my_size += 2;
        }
        if let Some(v) = self.inherit {
            my_size += 2;
        }
        if let Some(v) = self.inheritable {
            my_size += 2;
        }
        for value in &self.add {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.remove {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.inherited_members {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.inherited {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.inherit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.inheritable {
            os.write_bool(4, v)?;
        }
        for v in &self.add {
            os.write_uint32(5, *v)?;
        };
        for v in &self.remove {
            os.write_uint32(6, *v)?;
        };
        for v in &self.inherited_members {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_ChanGroup {
        ACL_ChanGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ACL_ChanGroup| { &m.name },
                |m: &mut ACL_ChanGroup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherited",
                |m: &ACL_ChanGroup| { &m.inherited },
                |m: &mut ACL_ChanGroup| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit",
                |m: &ACL_ChanGroup| { &m.inherit },
                |m: &mut ACL_ChanGroup| { &mut m.inherit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inheritable",
                |m: &ACL_ChanGroup| { &m.inheritable },
                |m: &mut ACL_ChanGroup| { &mut m.inheritable },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "add",
                |m: &ACL_ChanGroup| { &m.add },
                |m: &mut ACL_ChanGroup| { &mut m.add },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remove",
                |m: &ACL_ChanGroup| { &m.remove },
                |m: &mut ACL_ChanGroup| { &mut m.remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inherited_members",
                |m: &ACL_ChanGroup| { &m.inherited_members },
                |m: &mut ACL_ChanGroup| { &mut m.inherited_members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_ChanGroup>(
                "ACL.ChanGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_ChanGroup {
        static instance: ::protobuf::rt::LazyV2<ACL_ChanGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_ChanGroup::new)
    }
}

impl ::protobuf::Clear for ACL_ChanGroup {
    fn clear(&mut self) {
        self.name.clear();
        self.inherited = ::std::option::Option::None;
        self.inherit = ::std::option::Option::None;
        self.inheritable = ::std::option::Option::None;
        self.add.clear();
        self.remove.clear();
        self.inherited_members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_ChanGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_ChanGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_ChanACL {
    // message fields
    apply_here: ::std::option::Option<bool>,
    apply_subs: ::std::option::Option<bool>,
    inherited: ::std::option::Option<bool>,
    user_id: ::std::option::Option<u32>,
    group: ::protobuf::SingularField<::std::string::String>,
    grant: ::std::option::Option<u32>,
    deny: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_ChanACL {
    fn default() -> &'a ACL_ChanACL {
        <ACL_ChanACL as ::protobuf::Message>::default_instance()
    }
}

impl ACL_ChanACL {
    pub fn new() -> ACL_ChanACL {
        ::std::default::Default::default()
    }

    // optional bool apply_here = 1;


    pub fn get_apply_here(&self) -> bool {
        self.apply_here.unwrap_or(true)
    }
    pub fn clear_apply_here(&mut self) {
        self.apply_here = ::std::option::Option::None;
    }

    pub fn has_apply_here(&self) -> bool {
        self.apply_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_here(&mut self, v: bool) {
        self.apply_here = ::std::option::Option::Some(v);
    }

    // optional bool apply_subs = 2;


    pub fn get_apply_subs(&self) -> bool {
        self.apply_subs.unwrap_or(true)
    }
    pub fn clear_apply_subs(&mut self) {
        self.apply_subs = ::std::option::Option::None;
    }

    pub fn has_apply_subs(&self) -> bool {
        self.apply_subs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_subs(&mut self, v: bool) {
        self.apply_subs = ::std::option::Option::Some(v);
    }

    // optional bool inherited = 3;


    pub fn get_inherited(&self) -> bool {
        self.inherited.unwrap_or(true)
    }
    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    // optional uint32 user_id = 4;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional string group = 5;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 grant = 6;


    pub fn get_grant(&self) -> u32 {
        self.grant.unwrap_or(0)
    }
    pub fn clear_grant(&mut self) {
        self.grant = ::std::option::Option::None;
    }

    pub fn has_grant(&self) -> bool {
        self.grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant(&mut self, v: u32) {
        self.grant = ::std::option::Option::Some(v);
    }

    // optional uint32 deny = 7;


    pub fn get_deny(&self) -> u32 {
        self.deny.unwrap_or(0)
    }
    pub fn clear_deny(&mut self) {
        self.deny = ::std::option::Option::None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: u32) {
        self.deny = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ACL_ChanACL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.apply_here = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.apply_subs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.grant = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deny = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.apply_here {
            my_size += 2;
        }
        if let Some(v) = self.apply_subs {
            my_size += 2;
        }
        if let Some(v) = self.inherited {
            my_size += 2;
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.grant {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deny {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.apply_here {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.apply_subs {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.inherited {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.grant {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.deny {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_ChanACL {
        ACL_ChanACL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "apply_here",
                |m: &ACL_ChanACL| { &m.apply_here },
                |m: &mut ACL_ChanACL| { &mut m.apply_here },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "apply_subs",
                |m: &ACL_ChanACL| { &m.apply_subs },
                |m: &mut ACL_ChanACL| { &mut m.apply_subs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherited",
                |m: &ACL_ChanACL| { &m.inherited },
                |m: &mut ACL_ChanACL| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_id",
                |m: &ACL_ChanACL| { &m.user_id },
                |m: &mut ACL_ChanACL| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &ACL_ChanACL| { &m.group },
                |m: &mut ACL_ChanACL| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "grant",
                |m: &ACL_ChanACL| { &m.grant },
                |m: &mut ACL_ChanACL| { &mut m.grant },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deny",
                |m: &ACL_ChanACL| { &m.deny },
                |m: &mut ACL_ChanACL| { &mut m.deny },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_ChanACL>(
                "ACL.ChanACL",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_ChanACL {
        static instance: ::protobuf::rt::LazyV2<ACL_ChanACL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_ChanACL::new)
    }
}

impl ::protobuf::Clear for ACL_ChanACL {
    fn clear(&mut self) {
        self.apply_here = ::std::option::Option::None;
        self.apply_subs = ::std::option::Option::None;
        self.inherited = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.group.clear();
        self.grant = ::std::option::Option::None;
        self.deny = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_ChanACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_ChanACL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryUsers {
    // message fields
    pub ids: ::std::vec::Vec<u32>,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryUsers {
    fn default() -> &'a QueryUsers {
        <QueryUsers as ::protobuf::Message>::default_instance()
    }
}

impl QueryUsers {
    pub fn new() -> QueryUsers {
        ::std::default::Default::default()
    }

    // repeated uint32 ids = 1;


    pub fn get_ids(&self) -> &[u32] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    // repeated string names = 2;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryUsers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryUsers {
        QueryUsers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ids",
                |m: &QueryUsers| { &m.ids },
                |m: &mut QueryUsers| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "names",
                |m: &QueryUsers| { &m.names },
                |m: &mut QueryUsers| { &mut m.names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryUsers>(
                "QueryUsers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryUsers {
        static instance: ::protobuf::rt::LazyV2<QueryUsers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryUsers::new)
    }
}

impl ::protobuf::Clear for QueryUsers {
    fn clear(&mut self) {
        self.ids.clear();
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUsers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CryptSetup {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    client_nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    server_nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CryptSetup {
    fn default() -> &'a CryptSetup {
        <CryptSetup as ::protobuf::Message>::default_instance()
    }
}

impl CryptSetup {
    pub fn new() -> CryptSetup {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes client_nonce = 2;


    pub fn get_client_nonce(&self) -> &[u8] {
        match self.client_nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_client_nonce(&mut self) {
        self.client_nonce.clear();
    }

    pub fn has_client_nonce(&self) -> bool {
        self.client_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.client_nonce.is_none() {
            self.client_nonce.set_default();
        }
        self.client_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.client_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes server_nonce = 3;


    pub fn get_server_nonce(&self) -> &[u8] {
        match self.server_nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_server_nonce(&mut self) {
        self.server_nonce.clear();
    }

    pub fn has_server_nonce(&self) -> bool {
        self.server_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.server_nonce.is_none() {
            self.server_nonce.set_default();
        }
        self.server_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.server_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CryptSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.client_nonce)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.server_nonce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.client_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.server_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.client_nonce.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.server_nonce.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CryptSetup {
        CryptSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &CryptSetup| { &m.key },
                |m: &mut CryptSetup| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "client_nonce",
                |m: &CryptSetup| { &m.client_nonce },
                |m: &mut CryptSetup| { &mut m.client_nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "server_nonce",
                |m: &CryptSetup| { &m.server_nonce },
                |m: &mut CryptSetup| { &mut m.server_nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CryptSetup>(
                "CryptSetup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CryptSetup {
        static instance: ::protobuf::rt::LazyV2<CryptSetup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CryptSetup::new)
    }
}

impl ::protobuf::Clear for CryptSetup {
    fn clear(&mut self) {
        self.key.clear();
        self.client_nonce.clear();
        self.server_nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CryptSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextActionModify {
    // message fields
    action: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    context: ::std::option::Option<u32>,
    operation: ::std::option::Option<ContextActionModify_Operation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextActionModify {
    fn default() -> &'a ContextActionModify {
        <ContextActionModify as ::protobuf::Message>::default_instance()
    }
}

impl ContextActionModify {
    pub fn new() -> ContextActionModify {
        ::std::default::Default::default()
    }

    // required string action = 1;


    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 context = 3;


    pub fn get_context(&self) -> u32 {
        self.context.unwrap_or(0)
    }
    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    // optional .MumbleProto.ContextActionModify.Operation operation = 4;


    pub fn get_operation(&self) -> ContextActionModify_Operation {
        self.operation.unwrap_or(ContextActionModify_Operation::Add)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ContextActionModify_Operation) {
        self.operation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContextActionModify {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.context = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.context {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.operation {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextActionModify {
        ContextActionModify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &ContextActionModify| { &m.action },
                |m: &mut ContextActionModify| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &ContextActionModify| { &m.text },
                |m: &mut ContextActionModify| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "context",
                |m: &ContextActionModify| { &m.context },
                |m: &mut ContextActionModify| { &mut m.context },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContextActionModify_Operation>>(
                "operation",
                |m: &ContextActionModify| { &m.operation },
                |m: &mut ContextActionModify| { &mut m.operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextActionModify>(
                "ContextActionModify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextActionModify {
        static instance: ::protobuf::rt::LazyV2<ContextActionModify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextActionModify::new)
    }
}

impl ::protobuf::Clear for ContextActionModify {
    fn clear(&mut self) {
        self.action.clear();
        self.text.clear();
        self.context = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextActionModify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextActionModify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContextActionModify_Context {
    Server = 1,
    Channel = 2,
    User = 4,
}

impl ::protobuf::ProtobufEnum for ContextActionModify_Context {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContextActionModify_Context> {
        match value {
            1 => ::std::option::Option::Some(ContextActionModify_Context::Server),
            2 => ::std::option::Option::Some(ContextActionModify_Context::Channel),
            4 => ::std::option::Option::Some(ContextActionModify_Context::User),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContextActionModify_Context] = &[
            ContextActionModify_Context::Server,
            ContextActionModify_Context::Channel,
            ContextActionModify_Context::User,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContextActionModify_Context>("ContextActionModify.Context", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContextActionModify_Context {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ContextActionModify_Context {
    fn default() -> Self {
        ContextActionModify_Context::Server
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextActionModify_Context {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContextActionModify_Operation {
    Add = 0,
    Remove = 1,
}

impl ::protobuf::ProtobufEnum for ContextActionModify_Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContextActionModify_Operation> {
        match value {
            0 => ::std::option::Option::Some(ContextActionModify_Operation::Add),
            1 => ::std::option::Option::Some(ContextActionModify_Operation::Remove),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContextActionModify_Operation] = &[
            ContextActionModify_Operation::Add,
            ContextActionModify_Operation::Remove,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContextActionModify_Operation>("ContextActionModify.Operation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContextActionModify_Operation {
}

impl ::std::default::Default for ContextActionModify_Operation {
    fn default() -> Self {
        ContextActionModify_Operation::Add
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextActionModify_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextAction {
    // message fields
    session: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    action: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextAction {
    fn default() -> &'a ContextAction {
        <ContextAction as ::protobuf::Message>::default_instance()
    }
}

impl ContextAction {
    pub fn new() -> ContextAction {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 2;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // required string action = 3;


    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContextAction {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextAction {
        ContextAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &ContextAction| { &m.session },
                |m: &mut ContextAction| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &ContextAction| { &m.channel_id },
                |m: &mut ContextAction| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &ContextAction| { &m.action },
                |m: &mut ContextAction| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextAction>(
                "ContextAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextAction {
        static instance: ::protobuf::rt::LazyV2<ContextAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextAction::new)
    }
}

impl ::protobuf::Clear for ContextAction {
    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserList {
    // message fields
    pub users: ::protobuf::RepeatedField<UserList_User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserList {
    fn default() -> &'a UserList {
        <UserList as ::protobuf::Message>::default_instance()
    }
}

impl UserList {
    pub fn new() -> UserList {
        ::std::default::Default::default()
    }

    // repeated .MumbleProto.UserList.User users = 1;


    pub fn get_users(&self) -> &[UserList_User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<UserList_User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<UserList_User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<UserList_User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UserList {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserList {
        UserList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserList_User>>(
                "users",
                |m: &UserList| { &m.users },
                |m: &mut UserList| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserList>(
                "UserList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserList {
        static instance: ::protobuf::rt::LazyV2<UserList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserList::new)
    }
}

impl ::protobuf::Clear for UserList {
    fn clear(&mut self) {
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserList_User {
    // message fields
    user_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    last_seen: ::protobuf::SingularField<::std::string::String>,
    last_channel: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserList_User {
    fn default() -> &'a UserList_User {
        <UserList_User as ::protobuf::Message>::default_instance()
    }
}

impl UserList_User {
    pub fn new() -> UserList_User {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_seen = 3;


    pub fn get_last_seen(&self) -> &str {
        match self.last_seen.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_seen(&mut self) {
        self.last_seen.clear();
    }

    pub fn has_last_seen(&self) -> bool {
        self.last_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen(&mut self, v: ::std::string::String) {
        self.last_seen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_seen(&mut self) -> &mut ::std::string::String {
        if self.last_seen.is_none() {
            self.last_seen.set_default();
        }
        self.last_seen.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_seen(&mut self) -> ::std::string::String {
        self.last_seen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 last_channel = 4;


    pub fn get_last_channel(&self) -> u32 {
        self.last_channel.unwrap_or(0)
    }
    pub fn clear_last_channel(&mut self) {
        self.last_channel = ::std::option::Option::None;
    }

    pub fn has_last_channel(&self) -> bool {
        self.last_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_channel(&mut self, v: u32) {
        self.last_channel = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserList_User {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_seen)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_channel = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.last_seen.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.last_channel {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.last_seen.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.last_channel {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserList_User {
        UserList_User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_id",
                |m: &UserList_User| { &m.user_id },
                |m: &mut UserList_User| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserList_User| { &m.name },
                |m: &mut UserList_User| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_seen",
                |m: &UserList_User| { &m.last_seen },
                |m: &mut UserList_User| { &mut m.last_seen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_channel",
                |m: &UserList_User| { &m.last_channel },
                |m: &mut UserList_User| { &mut m.last_channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserList_User>(
                "UserList.User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserList_User {
        static instance: ::protobuf::rt::LazyV2<UserList_User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserList_User::new)
    }
}

impl ::protobuf::Clear for UserList_User {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.name.clear();
        self.last_seen.clear();
        self.last_channel = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserList_User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserList_User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoiceTarget {
    // message fields
    id: ::std::option::Option<u32>,
    pub targets: ::protobuf::RepeatedField<VoiceTarget_Target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoiceTarget {
    fn default() -> &'a VoiceTarget {
        <VoiceTarget as ::protobuf::Message>::default_instance()
    }
}

impl VoiceTarget {
    pub fn new() -> VoiceTarget {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated .MumbleProto.VoiceTarget.Target targets = 2;


    pub fn get_targets(&self) -> &[VoiceTarget_Target] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<VoiceTarget_Target>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<VoiceTarget_Target> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<VoiceTarget_Target> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoiceTarget {
    fn is_initialized(&self) -> bool {
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.targets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoiceTarget {
        VoiceTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &VoiceTarget| { &m.id },
                |m: &mut VoiceTarget| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoiceTarget_Target>>(
                "targets",
                |m: &VoiceTarget| { &m.targets },
                |m: &mut VoiceTarget| { &mut m.targets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoiceTarget>(
                "VoiceTarget",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoiceTarget {
        static instance: ::protobuf::rt::LazyV2<VoiceTarget> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoiceTarget::new)
    }
}

impl ::protobuf::Clear for VoiceTarget {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoiceTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoiceTarget_Target {
    // message fields
    pub session: ::std::vec::Vec<u32>,
    channel_id: ::std::option::Option<u32>,
    group: ::protobuf::SingularField<::std::string::String>,
    links: ::std::option::Option<bool>,
    children: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoiceTarget_Target {
    fn default() -> &'a VoiceTarget_Target {
        <VoiceTarget_Target as ::protobuf::Message>::default_instance()
    }
}

impl VoiceTarget_Target {
    pub fn new() -> VoiceTarget_Target {
        ::std::default::Default::default()
    }

    // repeated uint32 session = 1;


    pub fn get_session(&self) -> &[u32] {
        &self.session
    }
    pub fn clear_session(&mut self) {
        self.session.clear();
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::vec::Vec<u32>) {
        self.session = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.session
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session, ::std::vec::Vec::new())
    }

    // optional uint32 channel_id = 2;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional string group = 3;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool links = 4;


    pub fn get_links(&self) -> bool {
        self.links.unwrap_or(false)
    }
    pub fn clear_links(&mut self) {
        self.links = ::std::option::Option::None;
    }

    pub fn has_links(&self) -> bool {
        self.links.is_some()
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: bool) {
        self.links = ::std::option::Option::Some(v);
    }

    // optional bool children = 5;


    pub fn get_children(&self) -> bool {
        self.children.unwrap_or(false)
    }
    pub fn clear_children(&mut self) {
        self.children = ::std::option::Option::None;
    }

    pub fn has_children(&self) -> bool {
        self.children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: bool) {
        self.children = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VoiceTarget_Target {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.links = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.children = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.session {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.links {
            my_size += 2;
        }
        if let Some(v) = self.children {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.session {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.channel_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.links {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.children {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoiceTarget_Target {
        VoiceTarget_Target::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &VoiceTarget_Target| { &m.session },
                |m: &mut VoiceTarget_Target| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &VoiceTarget_Target| { &m.channel_id },
                |m: &mut VoiceTarget_Target| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &VoiceTarget_Target| { &m.group },
                |m: &mut VoiceTarget_Target| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "links",
                |m: &VoiceTarget_Target| { &m.links },
                |m: &mut VoiceTarget_Target| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "children",
                |m: &VoiceTarget_Target| { &m.children },
                |m: &mut VoiceTarget_Target| { &mut m.children },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoiceTarget_Target>(
                "VoiceTarget.Target",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoiceTarget_Target {
        static instance: ::protobuf::rt::LazyV2<VoiceTarget_Target> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoiceTarget_Target::new)
    }
}

impl ::protobuf::Clear for VoiceTarget_Target {
    fn clear(&mut self) {
        self.session.clear();
        self.channel_id = ::std::option::Option::None;
        self.group.clear();
        self.links = ::std::option::Option::None;
        self.children = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoiceTarget_Target {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceTarget_Target {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PermissionQuery {
    // message fields
    channel_id: ::std::option::Option<u32>,
    permissions: ::std::option::Option<u32>,
    flush: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PermissionQuery {
    fn default() -> &'a PermissionQuery {
        <PermissionQuery as ::protobuf::Message>::default_instance()
    }
}

impl PermissionQuery {
    pub fn new() -> PermissionQuery {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;


    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 2;


    pub fn get_permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }
    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional bool flush = 3;


    pub fn get_flush(&self) -> bool {
        self.flush.unwrap_or(false)
    }
    pub fn clear_flush(&mut self) {
        self.flush = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        self.flush.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: bool) {
        self.flush = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PermissionQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.permissions = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flush = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flush {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flush {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PermissionQuery {
        PermissionQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_id",
                |m: &PermissionQuery| { &m.channel_id },
                |m: &mut PermissionQuery| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "permissions",
                |m: &PermissionQuery| { &m.permissions },
                |m: &mut PermissionQuery| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flush",
                |m: &PermissionQuery| { &m.flush },
                |m: &mut PermissionQuery| { &mut m.flush },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PermissionQuery>(
                "PermissionQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PermissionQuery {
        static instance: ::protobuf::rt::LazyV2<PermissionQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PermissionQuery::new)
    }
}

impl ::protobuf::Clear for PermissionQuery {
    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.flush = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PermissionQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodecVersion {
    // message fields
    alpha: ::std::option::Option<i32>,
    beta: ::std::option::Option<i32>,
    prefer_alpha: ::std::option::Option<bool>,
    opus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodecVersion {
    fn default() -> &'a CodecVersion {
        <CodecVersion as ::protobuf::Message>::default_instance()
    }
}

impl CodecVersion {
    pub fn new() -> CodecVersion {
        ::std::default::Default::default()
    }

    // required int32 alpha = 1;


    pub fn get_alpha(&self) -> i32 {
        self.alpha.unwrap_or(0)
    }
    pub fn clear_alpha(&mut self) {
        self.alpha = ::std::option::Option::None;
    }

    pub fn has_alpha(&self) -> bool {
        self.alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: i32) {
        self.alpha = ::std::option::Option::Some(v);
    }

    // required int32 beta = 2;


    pub fn get_beta(&self) -> i32 {
        self.beta.unwrap_or(0)
    }
    pub fn clear_beta(&mut self) {
        self.beta = ::std::option::Option::None;
    }

    pub fn has_beta(&self) -> bool {
        self.beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta(&mut self, v: i32) {
        self.beta = ::std::option::Option::Some(v);
    }

    // required bool prefer_alpha = 3;


    pub fn get_prefer_alpha(&self) -> bool {
        self.prefer_alpha.unwrap_or(true)
    }
    pub fn clear_prefer_alpha(&mut self) {
        self.prefer_alpha = ::std::option::Option::None;
    }

    pub fn has_prefer_alpha(&self) -> bool {
        self.prefer_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_alpha(&mut self, v: bool) {
        self.prefer_alpha = ::std::option::Option::Some(v);
    }

    // optional bool opus = 4;


    pub fn get_opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }
    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CodecVersion {
    fn is_initialized(&self) -> bool {
        if self.alpha.is_none() {
            return false;
        }
        if self.beta.is_none() {
            return false;
        }
        if self.prefer_alpha.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.alpha = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.beta = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefer_alpha = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.alpha {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.beta {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prefer_alpha {
            my_size += 2;
        }
        if let Some(v) = self.opus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.alpha {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.beta {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.prefer_alpha {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.opus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodecVersion {
        CodecVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "alpha",
                |m: &CodecVersion| { &m.alpha },
                |m: &mut CodecVersion| { &mut m.alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "beta",
                |m: &CodecVersion| { &m.beta },
                |m: &mut CodecVersion| { &mut m.beta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prefer_alpha",
                |m: &CodecVersion| { &m.prefer_alpha },
                |m: &mut CodecVersion| { &mut m.prefer_alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "opus",
                |m: &CodecVersion| { &m.opus },
                |m: &mut CodecVersion| { &mut m.opus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodecVersion>(
                "CodecVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CodecVersion {
        static instance: ::protobuf::rt::LazyV2<CodecVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CodecVersion::new)
    }
}

impl ::protobuf::Clear for CodecVersion {
    fn clear(&mut self) {
        self.alpha = ::std::option::Option::None;
        self.beta = ::std::option::Option::None;
        self.prefer_alpha = ::std::option::Option::None;
        self.opus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodecVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodecVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserStats {
    // message fields
    session: ::std::option::Option<u32>,
    stats_only: ::std::option::Option<bool>,
    pub certificates: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub from_client: ::protobuf::SingularPtrField<UserStats_Stats>,
    pub from_server: ::protobuf::SingularPtrField<UserStats_Stats>,
    udp_packets: ::std::option::Option<u32>,
    tcp_packets: ::std::option::Option<u32>,
    udp_ping_avg: ::std::option::Option<f32>,
    udp_ping_var: ::std::option::Option<f32>,
    tcp_ping_avg: ::std::option::Option<f32>,
    tcp_ping_var: ::std::option::Option<f32>,
    pub version: ::protobuf::SingularPtrField<Version>,
    pub celt_versions: ::std::vec::Vec<i32>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bandwidth: ::std::option::Option<u32>,
    onlinesecs: ::std::option::Option<u32>,
    idlesecs: ::std::option::Option<u32>,
    strong_certificate: ::std::option::Option<bool>,
    opus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserStats {
    fn default() -> &'a UserStats {
        <UserStats as ::protobuf::Message>::default_instance()
    }
}

impl UserStats {
    pub fn new() -> UserStats {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional bool stats_only = 2;


    pub fn get_stats_only(&self) -> bool {
        self.stats_only.unwrap_or(false)
    }
    pub fn clear_stats_only(&mut self) {
        self.stats_only = ::std::option::Option::None;
    }

    pub fn has_stats_only(&self) -> bool {
        self.stats_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_only(&mut self, v: bool) {
        self.stats_only = ::std::option::Option::Some(v);
    }

    // repeated bytes certificates = 3;


    pub fn get_certificates(&self) -> &[::std::vec::Vec<u8>] {
        &self.certificates
    }
    pub fn clear_certificates(&mut self) {
        self.certificates.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificates(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.certificates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_certificates(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.certificates
    }

    // Take field
    pub fn take_certificates(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.certificates, ::protobuf::RepeatedField::new())
    }

    // optional .MumbleProto.UserStats.Stats from_client = 4;


    pub fn get_from_client(&self) -> &UserStats_Stats {
        self.from_client.as_ref().unwrap_or_else(|| <UserStats_Stats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_client(&mut self) {
        self.from_client.clear();
    }

    pub fn has_from_client(&self) -> bool {
        self.from_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_client(&mut self, v: UserStats_Stats) {
        self.from_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_client(&mut self) -> &mut UserStats_Stats {
        if self.from_client.is_none() {
            self.from_client.set_default();
        }
        self.from_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_client(&mut self) -> UserStats_Stats {
        self.from_client.take().unwrap_or_else(|| UserStats_Stats::new())
    }

    // optional .MumbleProto.UserStats.Stats from_server = 5;


    pub fn get_from_server(&self) -> &UserStats_Stats {
        self.from_server.as_ref().unwrap_or_else(|| <UserStats_Stats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_server(&mut self) {
        self.from_server.clear();
    }

    pub fn has_from_server(&self) -> bool {
        self.from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_server(&mut self, v: UserStats_Stats) {
        self.from_server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_server(&mut self) -> &mut UserStats_Stats {
        if self.from_server.is_none() {
            self.from_server.set_default();
        }
        self.from_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_server(&mut self) -> UserStats_Stats {
        self.from_server.take().unwrap_or_else(|| UserStats_Stats::new())
    }

    // optional uint32 udp_packets = 6;


    pub fn get_udp_packets(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }
    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_packets = 7;


    pub fn get_tcp_packets(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }
    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_avg = 8;


    pub fn get_udp_ping_avg(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }
    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_var = 9;


    pub fn get_udp_ping_var(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }
    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_avg = 10;


    pub fn get_tcp_ping_avg(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }
    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_var = 11;


    pub fn get_tcp_ping_var(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }
    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }

    // optional .MumbleProto.Version version = 12;


    pub fn get_version(&self) -> &Version {
        self.version.as_ref().unwrap_or_else(|| <Version as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: Version) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut Version {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> Version {
        self.version.take().unwrap_or_else(|| Version::new())
    }

    // repeated int32 celt_versions = 13;


    pub fn get_celt_versions(&self) -> &[i32] {
        &self.celt_versions
    }
    pub fn clear_celt_versions(&mut self) {
        self.celt_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_celt_versions(&mut self, v: ::std::vec::Vec<i32>) {
        self.celt_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_celt_versions(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.celt_versions
    }

    // Take field
    pub fn take_celt_versions(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.celt_versions, ::std::vec::Vec::new())
    }

    // optional bytes address = 14;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 bandwidth = 15;


    pub fn get_bandwidth(&self) -> u32 {
        self.bandwidth.unwrap_or(0)
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    // optional uint32 onlinesecs = 16;


    pub fn get_onlinesecs(&self) -> u32 {
        self.onlinesecs.unwrap_or(0)
    }
    pub fn clear_onlinesecs(&mut self) {
        self.onlinesecs = ::std::option::Option::None;
    }

    pub fn has_onlinesecs(&self) -> bool {
        self.onlinesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onlinesecs(&mut self, v: u32) {
        self.onlinesecs = ::std::option::Option::Some(v);
    }

    // optional uint32 idlesecs = 17;


    pub fn get_idlesecs(&self) -> u32 {
        self.idlesecs.unwrap_or(0)
    }
    pub fn clear_idlesecs(&mut self) {
        self.idlesecs = ::std::option::Option::None;
    }

    pub fn has_idlesecs(&self) -> bool {
        self.idlesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idlesecs(&mut self, v: u32) {
        self.idlesecs = ::std::option::Option::Some(v);
    }

    // optional bool strong_certificate = 18;


    pub fn get_strong_certificate(&self) -> bool {
        self.strong_certificate.unwrap_or(false)
    }
    pub fn clear_strong_certificate(&mut self) {
        self.strong_certificate = ::std::option::Option::None;
    }

    pub fn has_strong_certificate(&self) -> bool {
        self.strong_certificate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strong_certificate(&mut self, v: bool) {
        self.strong_certificate = ::std::option::Option::Some(v);
    }

    // optional bool opus = 19;


    pub fn get_opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }
    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserStats {
    fn is_initialized(&self) -> bool {
        for v in &self.from_client {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.from_server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stats_only = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.certificates)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_client)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_server)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.udp_packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcp_packets = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.udp_ping_avg = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.udp_ping_var = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tcp_ping_avg = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tcp_ping_var = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.celt_versions)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.onlinesecs = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idlesecs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strong_certificate = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stats_only {
            my_size += 2;
        }
        for value in &self.certificates {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(ref v) = self.from_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.from_server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.udp_packets {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcp_packets {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.udp_ping_avg {
            my_size += 5;
        }
        if let Some(v) = self.udp_ping_var {
            my_size += 5;
        }
        if let Some(v) = self.tcp_ping_avg {
            my_size += 5;
        }
        if let Some(v) = self.tcp_ping_var {
            my_size += 5;
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.celt_versions {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.onlinesecs {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.idlesecs {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strong_certificate {
            my_size += 3;
        }
        if let Some(v) = self.opus {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stats_only {
            os.write_bool(2, v)?;
        }
        for v in &self.certificates {
            os.write_bytes(3, &v)?;
        };
        if let Some(ref v) = self.from_client.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.from_server.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.udp_packets {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tcp_packets {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.udp_ping_avg {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.udp_ping_var {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.tcp_ping_avg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.tcp_ping_var {
            os.write_float(11, v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.celt_versions {
            os.write_int32(13, *v)?;
        };
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(14, &v)?;
        }
        if let Some(v) = self.bandwidth {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.onlinesecs {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.idlesecs {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.strong_certificate {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.opus {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserStats {
        UserStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &UserStats| { &m.session },
                |m: &mut UserStats| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stats_only",
                |m: &UserStats| { &m.stats_only },
                |m: &mut UserStats| { &mut m.stats_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "certificates",
                |m: &UserStats| { &m.certificates },
                |m: &mut UserStats| { &mut m.certificates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserStats_Stats>>(
                "from_client",
                |m: &UserStats| { &m.from_client },
                |m: &mut UserStats| { &mut m.from_client },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserStats_Stats>>(
                "from_server",
                |m: &UserStats| { &m.from_server },
                |m: &mut UserStats| { &mut m.from_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "udp_packets",
                |m: &UserStats| { &m.udp_packets },
                |m: &mut UserStats| { &mut m.udp_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcp_packets",
                |m: &UserStats| { &m.tcp_packets },
                |m: &mut UserStats| { &mut m.tcp_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "udp_ping_avg",
                |m: &UserStats| { &m.udp_ping_avg },
                |m: &mut UserStats| { &mut m.udp_ping_avg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "udp_ping_var",
                |m: &UserStats| { &m.udp_ping_var },
                |m: &mut UserStats| { &mut m.udp_ping_var },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tcp_ping_avg",
                |m: &UserStats| { &m.tcp_ping_avg },
                |m: &mut UserStats| { &mut m.tcp_ping_avg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tcp_ping_var",
                |m: &UserStats| { &m.tcp_ping_var },
                |m: &mut UserStats| { &mut m.tcp_ping_var },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Version>>(
                "version",
                |m: &UserStats| { &m.version },
                |m: &mut UserStats| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "celt_versions",
                |m: &UserStats| { &m.celt_versions },
                |m: &mut UserStats| { &mut m.celt_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &UserStats| { &m.address },
                |m: &mut UserStats| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bandwidth",
                |m: &UserStats| { &m.bandwidth },
                |m: &mut UserStats| { &mut m.bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "onlinesecs",
                |m: &UserStats| { &m.onlinesecs },
                |m: &mut UserStats| { &mut m.onlinesecs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "idlesecs",
                |m: &UserStats| { &m.idlesecs },
                |m: &mut UserStats| { &mut m.idlesecs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "strong_certificate",
                |m: &UserStats| { &m.strong_certificate },
                |m: &mut UserStats| { &mut m.strong_certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "opus",
                |m: &UserStats| { &m.opus },
                |m: &mut UserStats| { &mut m.opus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserStats>(
                "UserStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserStats {
        static instance: ::protobuf::rt::LazyV2<UserStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserStats::new)
    }
}

impl ::protobuf::Clear for UserStats {
    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.stats_only = ::std::option::Option::None;
        self.certificates.clear();
        self.from_client.clear();
        self.from_server.clear();
        self.udp_packets = ::std::option::Option::None;
        self.tcp_packets = ::std::option::Option::None;
        self.udp_ping_avg = ::std::option::Option::None;
        self.udp_ping_var = ::std::option::Option::None;
        self.tcp_ping_avg = ::std::option::Option::None;
        self.tcp_ping_var = ::std::option::Option::None;
        self.version.clear();
        self.celt_versions.clear();
        self.address.clear();
        self.bandwidth = ::std::option::Option::None;
        self.onlinesecs = ::std::option::Option::None;
        self.idlesecs = ::std::option::Option::None;
        self.strong_certificate = ::std::option::Option::None;
        self.opus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserStats_Stats {
    // message fields
    good: ::std::option::Option<u32>,
    late: ::std::option::Option<u32>,
    lost: ::std::option::Option<u32>,
    resync: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserStats_Stats {
    fn default() -> &'a UserStats_Stats {
        <UserStats_Stats as ::protobuf::Message>::default_instance()
    }
}

impl UserStats_Stats {
    pub fn new() -> UserStats_Stats {
        ::std::default::Default::default()
    }

    // optional uint32 good = 1;


    pub fn get_good(&self) -> u32 {
        self.good.unwrap_or(0)
    }
    pub fn clear_good(&mut self) {
        self.good = ::std::option::Option::None;
    }

    pub fn has_good(&self) -> bool {
        self.good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good(&mut self, v: u32) {
        self.good = ::std::option::Option::Some(v);
    }

    // optional uint32 late = 2;


    pub fn get_late(&self) -> u32 {
        self.late.unwrap_or(0)
    }
    pub fn clear_late(&mut self) {
        self.late = ::std::option::Option::None;
    }

    pub fn has_late(&self) -> bool {
        self.late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late(&mut self, v: u32) {
        self.late = ::std::option::Option::Some(v);
    }

    // optional uint32 lost = 3;


    pub fn get_lost(&self) -> u32 {
        self.lost.unwrap_or(0)
    }
    pub fn clear_lost(&mut self) {
        self.lost = ::std::option::Option::None;
    }

    pub fn has_lost(&self) -> bool {
        self.lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lost(&mut self, v: u32) {
        self.lost = ::std::option::Option::Some(v);
    }

    // optional uint32 resync = 4;


    pub fn get_resync(&self) -> u32 {
        self.resync.unwrap_or(0)
    }
    pub fn clear_resync(&mut self) {
        self.resync = ::std::option::Option::None;
    }

    pub fn has_resync(&self) -> bool {
        self.resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resync(&mut self, v: u32) {
        self.resync = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserStats_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.good = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.late = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lost = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resync = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.good {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.late {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lost {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resync {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.good {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.late {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lost {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.resync {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserStats_Stats {
        UserStats_Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "good",
                |m: &UserStats_Stats| { &m.good },
                |m: &mut UserStats_Stats| { &mut m.good },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "late",
                |m: &UserStats_Stats| { &m.late },
                |m: &mut UserStats_Stats| { &mut m.late },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lost",
                |m: &UserStats_Stats| { &m.lost },
                |m: &mut UserStats_Stats| { &mut m.lost },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resync",
                |m: &UserStats_Stats| { &m.resync },
                |m: &mut UserStats_Stats| { &mut m.resync },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserStats_Stats>(
                "UserStats.Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserStats_Stats {
        static instance: ::protobuf::rt::LazyV2<UserStats_Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserStats_Stats::new)
    }
}

impl ::protobuf::Clear for UserStats_Stats {
    fn clear(&mut self) {
        self.good = ::std::option::Option::None;
        self.late = ::std::option::Option::None;
        self.lost = ::std::option::Option::None;
        self.resync = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserStats_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStats_Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestBlob {
    // message fields
    pub session_texture: ::std::vec::Vec<u32>,
    pub session_comment: ::std::vec::Vec<u32>,
    pub channel_description: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestBlob {
    fn default() -> &'a RequestBlob {
        <RequestBlob as ::protobuf::Message>::default_instance()
    }
}

impl RequestBlob {
    pub fn new() -> RequestBlob {
        ::std::default::Default::default()
    }

    // repeated uint32 session_texture = 1;


    pub fn get_session_texture(&self) -> &[u32] {
        &self.session_texture
    }
    pub fn clear_session_texture(&mut self) {
        self.session_texture.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_texture(&mut self, v: ::std::vec::Vec<u32>) {
        self.session_texture = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_texture(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.session_texture
    }

    // Take field
    pub fn take_session_texture(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session_texture, ::std::vec::Vec::new())
    }

    // repeated uint32 session_comment = 2;


    pub fn get_session_comment(&self) -> &[u32] {
        &self.session_comment
    }
    pub fn clear_session_comment(&mut self) {
        self.session_comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_comment(&mut self, v: ::std::vec::Vec<u32>) {
        self.session_comment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_comment(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.session_comment
    }

    // Take field
    pub fn take_session_comment(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session_comment, ::std::vec::Vec::new())
    }

    // repeated uint32 channel_description = 3;


    pub fn get_channel_description(&self) -> &[u32] {
        &self.channel_description
    }
    pub fn clear_channel_description(&mut self) {
        self.channel_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_description(&mut self, v: ::std::vec::Vec<u32>) {
        self.channel_description = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_description(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.channel_description
    }

    // Take field
    pub fn take_channel_description(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.channel_description, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RequestBlob {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session_texture)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session_comment)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.channel_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.session_texture {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.session_comment {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.channel_description {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.session_texture {
            os.write_uint32(1, *v)?;
        };
        for v in &self.session_comment {
            os.write_uint32(2, *v)?;
        };
        for v in &self.channel_description {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestBlob {
        RequestBlob::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session_texture",
                |m: &RequestBlob| { &m.session_texture },
                |m: &mut RequestBlob| { &mut m.session_texture },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session_comment",
                |m: &RequestBlob| { &m.session_comment },
                |m: &mut RequestBlob| { &mut m.session_comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_description",
                |m: &RequestBlob| { &m.channel_description },
                |m: &mut RequestBlob| { &mut m.channel_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestBlob>(
                "RequestBlob",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestBlob {
        static instance: ::protobuf::rt::LazyV2<RequestBlob> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestBlob::new)
    }
}

impl ::protobuf::Clear for RequestBlob {
    fn clear(&mut self) {
        self.session_texture.clear();
        self.session_comment.clear();
        self.channel_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestBlob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestBlob {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerConfig {
    // message fields
    max_bandwidth: ::std::option::Option<u32>,
    welcome_text: ::protobuf::SingularField<::std::string::String>,
    allow_html: ::std::option::Option<bool>,
    message_length: ::std::option::Option<u32>,
    image_message_length: ::std::option::Option<u32>,
    max_users: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerConfig {
    fn default() -> &'a ServerConfig {
        <ServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    // optional uint32 max_bandwidth = 1;


    pub fn get_max_bandwidth(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }
    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    // optional string welcome_text = 2;


    pub fn get_welcome_text(&self) -> &str {
        match self.welcome_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_welcome_text(&mut self) {
        self.welcome_text.clear();
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text(&mut self) -> &mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text.set_default();
        }
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_html = 3;


    pub fn get_allow_html(&self) -> bool {
        self.allow_html.unwrap_or(false)
    }
    pub fn clear_allow_html(&mut self) {
        self.allow_html = ::std::option::Option::None;
    }

    pub fn has_allow_html(&self) -> bool {
        self.allow_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_html(&mut self, v: bool) {
        self.allow_html = ::std::option::Option::Some(v);
    }

    // optional uint32 message_length = 4;


    pub fn get_message_length(&self) -> u32 {
        self.message_length.unwrap_or(0)
    }
    pub fn clear_message_length(&mut self) {
        self.message_length = ::std::option::Option::None;
    }

    pub fn has_message_length(&self) -> bool {
        self.message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_length(&mut self, v: u32) {
        self.message_length = ::std::option::Option::Some(v);
    }

    // optional uint32 image_message_length = 5;


    pub fn get_image_message_length(&self) -> u32 {
        self.image_message_length.unwrap_or(0)
    }
    pub fn clear_image_message_length(&mut self) {
        self.image_message_length = ::std::option::Option::None;
    }

    pub fn has_image_message_length(&self) -> bool {
        self.image_message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_message_length(&mut self, v: u32) {
        self.image_message_length = ::std::option::Option::Some(v);
    }

    // optional uint32 max_users = 6;


    pub fn get_max_users(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }
    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_bandwidth = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.welcome_text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_html = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_length = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.image_message_length = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_users = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.max_bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.welcome_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_html {
            my_size += 2;
        }
        if let Some(v) = self.message_length {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_message_length {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_users {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_bandwidth {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.welcome_text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.allow_html {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.message_length {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.image_message_length {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_users {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_bandwidth",
                |m: &ServerConfig| { &m.max_bandwidth },
                |m: &mut ServerConfig| { &mut m.max_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "welcome_text",
                |m: &ServerConfig| { &m.welcome_text },
                |m: &mut ServerConfig| { &mut m.welcome_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_html",
                |m: &ServerConfig| { &m.allow_html },
                |m: &mut ServerConfig| { &mut m.allow_html },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "message_length",
                |m: &ServerConfig| { &m.message_length },
                |m: &mut ServerConfig| { &mut m.message_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "image_message_length",
                |m: &ServerConfig| { &m.image_message_length },
                |m: &mut ServerConfig| { &mut m.image_message_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_users",
                |m: &ServerConfig| { &m.max_users },
                |m: &mut ServerConfig| { &mut m.max_users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerConfig>(
                "ServerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerConfig {
        static instance: ::protobuf::rt::LazyV2<ServerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerConfig::new)
    }
}

impl ::protobuf::Clear for ServerConfig {
    fn clear(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
        self.welcome_text.clear();
        self.allow_html = ::std::option::Option::None;
        self.message_length = ::std::option::Option::None;
        self.image_message_length = ::std::option::Option::None;
        self.max_users = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SuggestConfig {
    // message fields
    version: ::std::option::Option<u32>,
    positional: ::std::option::Option<bool>,
    push_to_talk: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuggestConfig {
    fn default() -> &'a SuggestConfig {
        <SuggestConfig as ::protobuf::Message>::default_instance()
    }
}

impl SuggestConfig {
    pub fn new() -> SuggestConfig {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bool positional = 2;


    pub fn get_positional(&self) -> bool {
        self.positional.unwrap_or(false)
    }
    pub fn clear_positional(&mut self) {
        self.positional = ::std::option::Option::None;
    }

    pub fn has_positional(&self) -> bool {
        self.positional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positional(&mut self, v: bool) {
        self.positional = ::std::option::Option::Some(v);
    }

    // optional bool push_to_talk = 3;


    pub fn get_push_to_talk(&self) -> bool {
        self.push_to_talk.unwrap_or(false)
    }
    pub fn clear_push_to_talk(&mut self) {
        self.push_to_talk = ::std::option::Option::None;
    }

    pub fn has_push_to_talk(&self) -> bool {
        self.push_to_talk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_talk(&mut self, v: bool) {
        self.push_to_talk = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SuggestConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.positional = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.push_to_talk = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.positional {
            my_size += 2;
        }
        if let Some(v) = self.push_to_talk {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.positional {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.push_to_talk {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SuggestConfig {
        SuggestConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &SuggestConfig| { &m.version },
                |m: &mut SuggestConfig| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "positional",
                |m: &SuggestConfig| { &m.positional },
                |m: &mut SuggestConfig| { &mut m.positional },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "push_to_talk",
                |m: &SuggestConfig| { &m.push_to_talk },
                |m: &mut SuggestConfig| { &mut m.push_to_talk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SuggestConfig>(
                "SuggestConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SuggestConfig {
        static instance: ::protobuf::rt::LazyV2<SuggestConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SuggestConfig::new)
    }
}

impl ::protobuf::Clear for SuggestConfig {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.positional = ::std::option::Option::None;
        self.push_to_talk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuggestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16src/proto/mumble.proto\x12\x0bMumbleProto\"l\n\x07Version\x12\x18\
    \n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x18\n\x07release\x18\
    \x02\x20\x01(\tR\x07release\x12\x0e\n\x02os\x18\x03\x20\x01(\tR\x02os\
    \x12\x1d\n\nos_version\x18\x04\x20\x01(\tR\tosVersion\"#\n\tUDPTunnel\
    \x12\x16\n\x06packet\x18\x01\x20\x02(\x0cR\x06packet\"\x9e\x01\n\x0cAuth\
    enticate\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\x1a\n\
    \x08password\x18\x02\x20\x01(\tR\x08password\x12\x16\n\x06tokens\x18\x03\
    \x20\x03(\tR\x06tokens\x12#\n\rcelt_versions\x18\x04\x20\x03(\x05R\x0cce\
    ltVersions\x12\x19\n\x04opus\x18\x05\x20\x01(\x08:\x05falseR\x04opus\"\
    \xc2\x02\n\x04Ping\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestamp\
    \x12\x12\n\x04good\x18\x02\x20\x01(\rR\x04good\x12\x12\n\x04late\x18\x03\
    \x20\x01(\rR\x04late\x12\x12\n\x04lost\x18\x04\x20\x01(\rR\x04lost\x12\
    \x16\n\x06resync\x18\x05\x20\x01(\rR\x06resync\x12\x1f\n\x0budp_packets\
    \x18\x06\x20\x01(\rR\nudpPackets\x12\x1f\n\x0btcp_packets\x18\x07\x20\
    \x01(\rR\ntcpPackets\x12\x20\n\x0cudp_ping_avg\x18\x08\x20\x01(\x02R\nud\
    pPingAvg\x12\x20\n\x0cudp_ping_var\x18\t\x20\x01(\x02R\nudpPingVar\x12\
    \x20\n\x0ctcp_ping_avg\x18\n\x20\x01(\x02R\ntcpPingAvg\x12\x20\n\x0ctcp_\
    ping_var\x18\x0b\x20\x01(\x02R\ntcpPingVar\"\x85\x02\n\x06Reject\x122\n\
    \x04type\x18\x01\x20\x01(\x0e2\x1e.MumbleProto.Reject.RejectTypeR\x04typ\
    e\x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reason\"\xae\x01\n\nRejectT\
    ype\x12\x08\n\x04None\x10\0\x12\x10\n\x0cWrongVersion\x10\x01\x12\x13\n\
    \x0fInvalidUsername\x10\x02\x12\x0f\n\x0bWrongUserPW\x10\x03\x12\x11\n\r\
    WrongServerPW\x10\x04\x12\x11\n\rUsernameInUse\x10\x05\x12\x0e\n\nServer\
    Full\x10\x06\x12\x11\n\rNoCertificate\x10\x07\x12\x15\n\x11Authenticator\
    Fail\x10\x08\"\x90\x01\n\nServerSync\x12\x18\n\x07session\x18\x01\x20\
    \x01(\rR\x07session\x12#\n\rmax_bandwidth\x18\x02\x20\x01(\rR\x0cmaxBand\
    width\x12!\n\x0cwelcome_text\x18\x03\x20\x01(\tR\x0bwelcomeText\x12\x20\
    \n\x0bpermissions\x18\x04\x20\x01(\x04R\x0bpermissions\".\n\rChannelRemo\
    ve\x12\x1d\n\nchannel_id\x18\x01\x20\x02(\rR\tchannelId\"\xaa\x03\n\x0cC\
    hannelState\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\rR\tchannelId\x12\x16\
    \n\x06parent\x18\x02\x20\x01(\rR\x06parent\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x14\n\x05links\x18\x04\x20\x03(\rR\x05links\x12\x20\
    \n\x0bdescription\x18\x05\x20\x01(\tR\x0bdescription\x12\x1b\n\tlinks_ad\
    d\x18\x06\x20\x03(\rR\x08linksAdd\x12!\n\x0clinks_remove\x18\x07\x20\x03\
    (\rR\x0blinksRemove\x12#\n\ttemporary\x18\x08\x20\x01(\x08:\x05falseR\tt\
    emporary\x12\x1d\n\x08position\x18\t\x20\x01(\x05:\x010R\x08position\x12\
    )\n\x10description_hash\x18\n\x20\x01(\x0cR\x0fdescriptionHash\x12\x1b\n\
    \tmax_users\x18\x0b\x20\x01(\rR\x08maxUsers\x12.\n\x13is_enter_restricte\
    d\x18\x0c\x20\x01(\x08R\x11isEnterRestricted\x12\x1b\n\tcan_enter\x18\r\
    \x20\x01(\x08R\x08canEnter\"f\n\nUserRemove\x12\x18\n\x07session\x18\x01\
    \x20\x02(\rR\x07session\x12\x14\n\x05actor\x18\x02\x20\x01(\rR\x05actor\
    \x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x10\n\x03ban\x18\
    \x04\x20\x01(\x08R\x03ban\"\xd2\x05\n\tUserState\x12\x18\n\x07session\
    \x18\x01\x20\x01(\rR\x07session\x12\x14\n\x05actor\x18\x02\x20\x01(\rR\
    \x05actor\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x17\n\x07use\
    r_id\x18\x04\x20\x01(\rR\x06userId\x12\x1d\n\nchannel_id\x18\x05\x20\x01\
    (\rR\tchannelId\x12\x12\n\x04mute\x18\x06\x20\x01(\x08R\x04mute\x12\x12\
    \n\x04deaf\x18\x07\x20\x01(\x08R\x04deaf\x12\x1a\n\x08suppress\x18\x08\
    \x20\x01(\x08R\x08suppress\x12\x1b\n\tself_mute\x18\t\x20\x01(\x08R\x08s\
    elfMute\x12\x1b\n\tself_deaf\x18\n\x20\x01(\x08R\x08selfDeaf\x12\x18\n\
    \x07texture\x18\x0b\x20\x01(\x0cR\x07texture\x12%\n\x0eplugin_context\
    \x18\x0c\x20\x01(\x0cR\rpluginContext\x12'\n\x0fplugin_identity\x18\r\
    \x20\x01(\tR\x0epluginIdentity\x12\x18\n\x07comment\x18\x0e\x20\x01(\tR\
    \x07comment\x12\x12\n\x04hash\x18\x0f\x20\x01(\tR\x04hash\x12!\n\x0ccomm\
    ent_hash\x18\x10\x20\x01(\x0cR\x0bcommentHash\x12!\n\x0ctexture_hash\x18\
    \x11\x20\x01(\x0cR\x0btextureHash\x12)\n\x10priority_speaker\x18\x12\x20\
    \x01(\x08R\x0fprioritySpeaker\x12\x1c\n\trecording\x18\x13\x20\x01(\x08R\
    \trecording\x126\n\x17temporary_access_tokens\x18\x14\x20\x03(\tR\x15tem\
    poraryAccessTokens\x122\n\x15listening_channel_add\x18\x15\x20\x03(\rR\
    \x13listeningChannelAdd\x128\n\x18listening_channel_remove\x18\x16\x20\
    \x03(\rR\x16listeningChannelRemove\"\x86\x02\n\x07BanList\x121\n\x04bans\
    \x18\x01\x20\x03(\x0b2\x1d.MumbleProto.BanList.BanEntryR\x04bans\x12\x1b\
    \n\x05query\x18\x02\x20\x01(\x08:\x05falseR\x05query\x1a\xaa\x01\n\x08Ba\
    nEntry\x12\x18\n\x07address\x18\x01\x20\x02(\x0cR\x07address\x12\x12\n\
    \x04mask\x18\x02\x20\x02(\rR\x04mask\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x12\n\x04hash\x18\x04\x20\x01(\tR\x04hash\x12\x16\n\x06r\
    eason\x18\x05\x20\x01(\tR\x06reason\x12\x14\n\x05start\x18\x06\x20\x01(\
    \tR\x05start\x12\x1a\n\x08duration\x18\x07\x20\x01(\rR\x08duration\"\x8f\
    \x01\n\x0bTextMessage\x12\x14\n\x05actor\x18\x01\x20\x01(\rR\x05actor\
    \x12\x18\n\x07session\x18\x02\x20\x03(\rR\x07session\x12\x1d\n\nchannel_\
    id\x18\x03\x20\x03(\rR\tchannelId\x12\x17\n\x07tree_id\x18\x04\x20\x03(\
    \rR\x06treeId\x12\x18\n\x07message\x18\x05\x20\x02(\tR\x07message\"\xdb\
    \x03\n\x10PermissionDenied\x12\x1e\n\npermission\x18\x01\x20\x01(\rR\npe\
    rmission\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\rR\tchannelId\x12\x18\n\
    \x07session\x18\x03\x20\x01(\rR\x07session\x12\x16\n\x06reason\x18\x04\
    \x20\x01(\tR\x06reason\x12:\n\x04type\x18\x05\x20\x01(\x0e2&.MumbleProto\
    .PermissionDenied.DenyTypeR\x04type\x12\x12\n\x04name\x18\x06\x20\x01(\t\
    R\x04name\"\x85\x02\n\x08DenyType\x12\x08\n\x04Text\x10\0\x12\x0e\n\nPer\
    mission\x10\x01\x12\r\n\tSuperUser\x10\x02\x12\x0f\n\x0bChannelName\x10\
    \x03\x12\x0f\n\x0bTextTooLong\x10\x04\x12\x07\n\x03H9K\x10\x05\x12\x14\n\
    \x10TemporaryChannel\x10\x06\x12\x16\n\x12MissingCertificate\x10\x07\x12\
    \x0c\n\x08UserName\x10\x08\x12\x0f\n\x0bChannelFull\x10\t\x12\x10\n\x0cN\
    estingLimit\x10\n\x12\x15\n\x11ChannelCountLimit\x10\x0b\x12\x18\n\x14Ch\
    annelListenerLimit\x10\x0c\x12\x15\n\x11UserListenerLimit\x10\r\"\x84\
    \x05\n\x03ACL\x12\x1d\n\nchannel_id\x18\x01\x20\x02(\rR\tchannelId\x12'\
    \n\x0cinherit_acls\x18\x02\x20\x01(\x08:\x04trueR\x0binheritAcls\x122\n\
    \x06groups\x18\x03\x20\x03(\x0b2\x1a.MumbleProto.ACL.ChanGroupR\x06group\
    s\x12,\n\x04acls\x18\x04\x20\x03(\x0b2\x18.MumbleProto.ACL.ChanACLR\x04a\
    cls\x12\x1b\n\x05query\x18\x05\x20\x01(\x08:\x05falseR\x05query\x1a\xe2\
    \x01\n\tChanGroup\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\"\n\
    \tinherited\x18\x02\x20\x01(\x08:\x04trueR\tinherited\x12\x1e\n\x07inher\
    it\x18\x03\x20\x01(\x08:\x04trueR\x07inherit\x12&\n\x0binheritable\x18\
    \x04\x20\x01(\x08:\x04trueR\x0binheritable\x12\x10\n\x03add\x18\x05\x20\
    \x03(\rR\x03add\x12\x16\n\x06remove\x18\x06\x20\x03(\rR\x06remove\x12+\n\
    \x11inherited_members\x18\x07\x20\x03(\rR\x10inheritedMembers\x1a\xd0\
    \x01\n\x07ChanACL\x12#\n\napply_here\x18\x01\x20\x01(\x08:\x04trueR\tapp\
    lyHere\x12#\n\napply_subs\x18\x02\x20\x01(\x08:\x04trueR\tapplySubs\x12\
    \"\n\tinherited\x18\x03\x20\x01(\x08:\x04trueR\tinherited\x12\x17\n\x07u\
    ser_id\x18\x04\x20\x01(\rR\x06userId\x12\x14\n\x05group\x18\x05\x20\x01(\
    \tR\x05group\x12\x14\n\x05grant\x18\x06\x20\x01(\rR\x05grant\x12\x12\n\
    \x04deny\x18\x07\x20\x01(\rR\x04deny\"4\n\nQueryUsers\x12\x10\n\x03ids\
    \x18\x01\x20\x03(\rR\x03ids\x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05na\
    mes\"d\n\nCryptSetup\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12!\
    \n\x0cclient_nonce\x18\x02\x20\x01(\x0cR\x0bclientNonce\x12!\n\x0cserver\
    _nonce\x18\x03\x20\x01(\x0cR\x0bserverNonce\"\xf5\x01\n\x13ContextAction\
    Modify\x12\x16\n\x06action\x18\x01\x20\x02(\tR\x06action\x12\x12\n\x04te\
    xt\x18\x02\x20\x01(\tR\x04text\x12\x18\n\x07context\x18\x03\x20\x01(\rR\
    \x07context\x12H\n\toperation\x18\x04\x20\x01(\x0e2*.MumbleProto.Context\
    ActionModify.OperationR\toperation\",\n\x07Context\x12\n\n\x06Server\x10\
    \x01\x12\x0b\n\x07Channel\x10\x02\x12\x08\n\x04User\x10\x04\"\x20\n\tOpe\
    ration\x12\x07\n\x03Add\x10\0\x12\n\n\x06Remove\x10\x01\"`\n\rContextAct\
    ion\x12\x18\n\x07session\x18\x01\x20\x01(\rR\x07session\x12\x1d\n\nchann\
    el_id\x18\x02\x20\x01(\rR\tchannelId\x12\x16\n\x06action\x18\x03\x20\x02\
    (\tR\x06action\"\xb1\x01\n\x08UserList\x120\n\x05users\x18\x01\x20\x03(\
    \x0b2\x1a.MumbleProto.UserList.UserR\x05users\x1as\n\x04User\x12\x17\n\
    \x07user_id\x18\x01\x20\x02(\rR\x06userId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x1b\n\tlast_seen\x18\x03\x20\x01(\tR\x08lastSeen\
    \x12!\n\x0clast_channel\x18\x04\x20\x01(\rR\x0blastChannel\"\xf2\x01\n\
    \x0bVoiceTarget\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x129\n\x07targ\
    ets\x18\x02\x20\x03(\x0b2\x1f.MumbleProto.VoiceTarget.TargetR\x07targets\
    \x1a\x97\x01\n\x06Target\x12\x18\n\x07session\x18\x01\x20\x03(\rR\x07ses\
    sion\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\rR\tchannelId\x12\x14\n\x05g\
    roup\x18\x03\x20\x01(\tR\x05group\x12\x1b\n\x05links\x18\x04\x20\x01(\
    \x08:\x05falseR\x05links\x12!\n\x08children\x18\x05\x20\x01(\x08:\x05fal\
    seR\x08children\"o\n\x0fPermissionQuery\x12\x1d\n\nchannel_id\x18\x01\
    \x20\x01(\rR\tchannelId\x12\x20\n\x0bpermissions\x18\x02\x20\x01(\rR\x0b\
    permissions\x12\x1b\n\x05flush\x18\x03\x20\x01(\x08:\x05falseR\x05flush\
    \"|\n\x0cCodecVersion\x12\x14\n\x05alpha\x18\x01\x20\x02(\x05R\x05alpha\
    \x12\x12\n\x04beta\x18\x02\x20\x02(\x05R\x04beta\x12'\n\x0cprefer_alpha\
    \x18\x03\x20\x02(\x08:\x04trueR\x0bpreferAlpha\x12\x19\n\x04opus\x18\x04\
    \x20\x01(\x08:\x05falseR\x04opus\"\xae\x06\n\tUserStats\x12\x18\n\x07ses\
    sion\x18\x01\x20\x01(\rR\x07session\x12$\n\nstats_only\x18\x02\x20\x01(\
    \x08:\x05falseR\tstatsOnly\x12\"\n\x0ccertificates\x18\x03\x20\x03(\x0cR\
    \x0ccertificates\x12=\n\x0bfrom_client\x18\x04\x20\x01(\x0b2\x1c.MumbleP\
    roto.UserStats.StatsR\nfromClient\x12=\n\x0bfrom_server\x18\x05\x20\x01(\
    \x0b2\x1c.MumbleProto.UserStats.StatsR\nfromServer\x12\x1f\n\x0budp_pack\
    ets\x18\x06\x20\x01(\rR\nudpPackets\x12\x1f\n\x0btcp_packets\x18\x07\x20\
    \x01(\rR\ntcpPackets\x12\x20\n\x0cudp_ping_avg\x18\x08\x20\x01(\x02R\nud\
    pPingAvg\x12\x20\n\x0cudp_ping_var\x18\t\x20\x01(\x02R\nudpPingVar\x12\
    \x20\n\x0ctcp_ping_avg\x18\n\x20\x01(\x02R\ntcpPingAvg\x12\x20\n\x0ctcp_\
    ping_var\x18\x0b\x20\x01(\x02R\ntcpPingVar\x12.\n\x07version\x18\x0c\x20\
    \x01(\x0b2\x14.MumbleProto.VersionR\x07version\x12#\n\rcelt_versions\x18\
    \r\x20\x03(\x05R\x0cceltVersions\x12\x18\n\x07address\x18\x0e\x20\x01(\
    \x0cR\x07address\x12\x1c\n\tbandwidth\x18\x0f\x20\x01(\rR\tbandwidth\x12\
    \x1e\n\nonlinesecs\x18\x10\x20\x01(\rR\nonlinesecs\x12\x1a\n\x08idlesecs\
    \x18\x11\x20\x01(\rR\x08idlesecs\x124\n\x12strong_certificate\x18\x12\
    \x20\x01(\x08:\x05falseR\x11strongCertificate\x12\x19\n\x04opus\x18\x13\
    \x20\x01(\x08:\x05falseR\x04opus\x1a[\n\x05Stats\x12\x12\n\x04good\x18\
    \x01\x20\x01(\rR\x04good\x12\x12\n\x04late\x18\x02\x20\x01(\rR\x04late\
    \x12\x12\n\x04lost\x18\x03\x20\x01(\rR\x04lost\x12\x16\n\x06resync\x18\
    \x04\x20\x01(\rR\x06resync\"\x90\x01\n\x0bRequestBlob\x12'\n\x0fsession_\
    texture\x18\x01\x20\x03(\rR\x0esessionTexture\x12'\n\x0fsession_comment\
    \x18\x02\x20\x03(\rR\x0esessionComment\x12/\n\x13channel_description\x18\
    \x03\x20\x03(\rR\x12channelDescription\"\xeb\x01\n\x0cServerConfig\x12#\
    \n\rmax_bandwidth\x18\x01\x20\x01(\rR\x0cmaxBandwidth\x12!\n\x0cwelcome_\
    text\x18\x02\x20\x01(\tR\x0bwelcomeText\x12\x1d\n\nallow_html\x18\x03\
    \x20\x01(\x08R\tallowHtml\x12%\n\x0emessage_length\x18\x04\x20\x01(\rR\r\
    messageLength\x120\n\x14image_message_length\x18\x05\x20\x01(\rR\x12imag\
    eMessageLength\x12\x1b\n\tmax_users\x18\x06\x20\x01(\rR\x08maxUsers\"k\n\
    \rSuggestConfig\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\
    \x1e\n\npositional\x18\x02\x20\x01(\x08R\npositional\x12\x20\n\x0cpush_t\
    o_talk\x18\x03\x20\x01(\x08R\npushToTalkB\x02H\x01J\x91\xe5\x01\n\x07\
    \x12\x05\x05\0\xc9\x04\x01\n\xff\x01\n\x01\x0c\x12\x03\x05\0\x122\xf4\
    \x01\x20Copyright\x202005-2020\x20The\x20Mumble\x20Developers.\x20All\
    \x20rights\x20reserved.\n\x20Use\x20of\x20this\x20source\x20code\x20is\
    \x20governed\x20by\x20a\x20BSD-style\x20license\n\x20that\x20can\x20be\
    \x20found\x20in\x20the\x20LICENSE\x20file\x20at\x20the\x20root\x20of\x20\
    the\n\x20Mumble\x20source\x20tree\x20or\x20at\x20<https://www.mumble.inf\
    o/LICENSE>.\n\n\x08\n\x01\x02\x12\x03\x07\0\x14\n\x08\n\x01\x08\x12\x03\
    \t\0\x1c\n\t\n\x02\x08\t\x12\x03\t\0\x1c\n\n\n\x02\x04\0\x12\x04\x0b\0\
    \x14\x01\n\n\n\x03\x04\0\x01\x12\x03\x0b\x08\x0f\nJ\n\x04\x04\0\x02\0\
    \x12\x03\r\x04\x20\x1a=\x202-byte\x20Major,\x201-byte\x20Minor\x20and\
    \x201-byte\x20Patch\x20version\x20number.\n\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\r\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\r\r\x13\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\r\x14\x1b\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\r\x1e\x1f\n#\n\x04\x04\0\x02\x01\x12\x03\x0f\x04\x20\x1a\x16\x20Cli\
    ent\x20release\x20name.\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0f\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0f\r\x13\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03\x0f\x14\x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x0f\x1e\x1f\n\x1e\n\x04\x04\0\x02\x02\x12\x03\x11\x04\x1b\x1a\x11\x20Cl\
    ient\x20OS\x20name.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x11\x04\x0c\
    \n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x11\r\x13\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x11\x14\x16\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x11\
    \x19\x1a\n!\n\x04\x04\0\x02\x03\x12\x03\x13\x04#\x1a\x14\x20Client\x20OS\
    \x20version.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x13\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x03\x05\x12\x03\x13\r\x13\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03\x13\x14\x1e\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x13!\"\n?\n\
    \x02\x04\x01\x12\x04\x17\0\x1a\x01\x1a3\x20Not\x20used.\x20Not\x20even\
    \x20for\x20tunneling\x20UDP\x20through\x20TCP.\n\n\n\n\x03\x04\x01\x01\
    \x12\x03\x17\x08\x11\n\x18\n\x04\x04\x01\x02\0\x12\x03\x19\x04\x1e\x1a\
    \x0b\x20Not\x20used.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x19\x04\x0c\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x19\r\x12\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x19\x13\x19\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x19\x1c\
    \x1d\nV\n\x02\x04\x02\x12\x04\x1d\0'\x01\x1aJ\x20Used\x20by\x20the\x20cl\
    ient\x20to\x20send\x20the\x20authentication\x20credentials\x20to\x20the\
    \x20server.\n\n\n\n\x03\x04\x02\x01\x12\x03\x1d\x08\x14\n&\n\x04\x04\x02\
    \x02\0\x12\x03\x1f\x04!\x1a\x19\x20UTF-8\x20encoded\x20username.\n\n\x0c\
    \n\x05\x04\x02\x02\0\x04\x12\x03\x1f\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03\x1f\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1f\x14\x1c\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1f\x1f\x20\n'\n\x04\x04\x02\x02\
    \x01\x12\x03!\x04!\x1a\x1a\x20Server\x20or\x20user\x20password.\n\n\x0c\
    \n\x05\x04\x02\x02\x01\x04\x12\x03!\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\
    \x05\x12\x03!\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03!\x14\x1c\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03!\x1f\x20\n>\n\x04\x04\x02\x02\x02\
    \x12\x03#\x04\x1f\x1a1\x20Additional\x20access\x20tokens\x20for\x20serve\
    r\x20ACL\x20groups.\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03#\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x03#\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03#\x14\x1a\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03#\x1d\
    \x1e\nR\n\x04\x04\x02\x02\x03\x12\x03%\x04%\x1aE\x20A\x20list\x20of\x20C\
    ELT\x20bitstream\x20version\x20constants\x20supported\x20by\x20the\x20cl\
    ient.\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03%\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x03\x05\x12\x03%\r\x12\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03%\
    \x13\x20\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03%#$\n\x0b\n\x04\x04\x02\
    \x02\x04\x12\x03&\x04-\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03&\x04\x0c\
    \n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03&\r\x11\n\x0c\n\x05\x04\x02\x02\
    \x04\x01\x12\x03&\x12\x16\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03&\x19\
    \x1a\n\x0c\n\x05\x04\x02\x02\x04\x08\x12\x03&\x1b,\n\x0c\n\x05\x04\x02\
    \x02\x04\x07\x12\x03&&+\n\xe4\x01\n\x02\x04\x03\x12\x04,\0C\x01\x1a\xd7\
    \x01\x20Sent\x20by\x20the\x20client\x20to\x20notify\x20the\x20server\x20\
    that\x20the\x20client\x20is\x20still\x20alive.\n\x20Server\x20must\x20re\
    ply\x20to\x20the\x20packet\x20with\x20the\x20same\x20timestamp\x20and\
    \x20its\x20own\n\x20good/late/lost/resync\x20numbers.\x20None\x20of\x20t\
    he\x20fields\x20is\x20strictly\x20required.\n\n\n\n\x03\x04\x03\x01\x12\
    \x03,\x08\x0c\nE\n\x04\x04\x03\x02\0\x12\x03.\x04\"\x1a8\x20Client\x20ti\
    mestamp.\x20Server\x20should\x20not\x20attempt\x20to\x20decode.\n\n\x0c\
    \n\x05\x04\x03\x02\0\x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03.\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03.\x14\x1d\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03.\x20!\n3\n\x04\x04\x03\x02\x01\x12\x030\
    \x04\x1d\x1a&\x20The\x20amount\x20of\x20good\x20packets\x20received.\n\n\
    \x0c\n\x05\x04\x03\x02\x01\x04\x12\x030\x04\x0c\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x030\r\x13\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x030\x14\x18\
    \n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x030\x1b\x1c\n3\n\x04\x04\x03\x02\
    \x02\x12\x032\x04\x1d\x1a&\x20The\x20amount\x20of\x20late\x20packets\x20\
    received.\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x032\x04\x0c\n\x0c\n\x05\
    \x04\x03\x02\x02\x05\x12\x032\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x032\x14\x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x032\x1b\x1c\n4\n\x04\
    \x04\x03\x02\x03\x12\x034\x04\x1d\x1a'\x20The\x20amount\x20of\x20packets\
    \x20never\x20received.\n\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x034\x04\
    \x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x034\r\x13\n\x0c\n\x05\x04\x03\
    \x02\x03\x01\x12\x034\x14\x18\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x034\
    \x1b\x1c\n+\n\x04\x04\x03\x02\x04\x12\x036\x04\x1f\x1a\x1e\x20The\x20amo\
    unt\x20of\x20nonce\x20resyncs.\n\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03\
    6\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x036\r\x13\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x036\x14\x1a\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x036\x1d\x1e\n8\n\x04\x04\x03\x02\x05\x12\x038\x04$\x1a+\x20The\x20tota\
    l\x20amount\x20of\x20UDP\x20packets\x20received.\n\n\x0c\n\x05\x04\x03\
    \x02\x05\x04\x12\x038\x04\x0c\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x038\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x038\x14\x1f\n\x0c\n\x05\x04\
    \x03\x02\x05\x03\x12\x038\"#\n8\n\x04\x04\x03\x02\x06\x12\x03:\x04$\x1a+\
    \x20The\x20total\x20amount\x20of\x20TCP\x20packets\x20received.\n\n\x0c\
    \n\x05\x04\x03\x02\x06\x04\x12\x03:\x04\x0c\n\x0c\n\x05\x04\x03\x02\x06\
    \x05\x12\x03:\r\x13\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03:\x14\x1f\n\
    \x0c\n\x05\x04\x03\x02\x06\x03\x12\x03:\"#\n\x20\n\x04\x04\x03\x02\x07\
    \x12\x03<\x04$\x1a\x13\x20UDP\x20ping\x20average.\n\n\x0c\n\x05\x04\x03\
    \x02\x07\x04\x12\x03<\x04\x0c\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03<\r\
    \x12\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03<\x13\x1f\n\x0c\n\x05\x04\
    \x03\x02\x07\x03\x12\x03<\"#\n!\n\x04\x04\x03\x02\x08\x12\x03>\x04$\x1a\
    \x14\x20UDP\x20ping\x20variance.\n\n\x0c\n\x05\x04\x03\x02\x08\x04\x12\
    \x03>\x04\x0c\n\x0c\n\x05\x04\x03\x02\x08\x05\x12\x03>\r\x12\n\x0c\n\x05\
    \x04\x03\x02\x08\x01\x12\x03>\x13\x1f\n\x0c\n\x05\x04\x03\x02\x08\x03\
    \x12\x03>\"#\n\x20\n\x04\x04\x03\x02\t\x12\x03@\x04%\x1a\x13\x20TCP\x20p\
    ing\x20average.\n\n\x0c\n\x05\x04\x03\x02\t\x04\x12\x03@\x04\x0c\n\x0c\n\
    \x05\x04\x03\x02\t\x05\x12\x03@\r\x12\n\x0c\n\x05\x04\x03\x02\t\x01\x12\
    \x03@\x13\x1f\n\x0c\n\x05\x04\x03\x02\t\x03\x12\x03@\"$\n!\n\x04\x04\x03\
    \x02\n\x12\x03B\x04%\x1a\x14\x20TCP\x20ping\x20variance.\n\n\x0c\n\x05\
    \x04\x03\x02\n\x04\x12\x03B\x04\x0c\n\x0c\n\x05\x04\x03\x02\n\x05\x12\
    \x03B\r\x12\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03B\x13\x1f\n\x0c\n\x05\
    \x04\x03\x02\n\x03\x12\x03B\"$\nE\n\x02\x04\x04\x12\x04F\0a\x01\x1a9\x20\
    Sent\x20by\x20the\x20server\x20when\x20it\x20rejects\x20the\x20user\x20c\
    onnection.\n\n\n\n\x03\x04\x04\x01\x12\x03F\x08\x0e\n\x0c\n\x04\x04\x04\
    \x04\0\x12\x04G\x04\\\x05\n\x0c\n\x05\x04\x04\x04\0\x01\x12\x03G\t\x13\n\
    a\n\x06\x04\x04\x04\0\x02\0\x12\x03J\x08\x11\x1aR\x20The\x20rejection\
    \x20reason\x20is\x20unknown\x20(details\x20should\x20be\x20available\n\
    \x20in\x20Reject.reason).\n\n\x0e\n\x07\x04\x04\x04\0\x02\0\x01\x12\x03J\
    \x08\x0c\n\x0e\n\x07\x04\x04\x04\0\x02\0\x02\x12\x03J\x0f\x10\nN\n\x06\
    \x04\x04\x04\0\x02\x01\x12\x03L\x08\x19\x1a?\x20The\x20client\x20attempt\
    ed\x20to\x20connect\x20with\x20an\x20incompatible\x20version.\n\n\x0e\n\
    \x07\x04\x04\x04\0\x02\x01\x01\x12\x03L\x08\x14\n\x0e\n\x07\x04\x04\x04\
    \0\x02\x01\x02\x12\x03L\x17\x18\nB\n\x06\x04\x04\x04\0\x02\x02\x12\x03N\
    \x08\x1c\x1a3\x20The\x20user\x20name\x20supplied\x20by\x20the\x20client\
    \x20was\x20invalid.\n\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x03N\x08\
    \x17\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x03N\x1a\x1b\nb\n\x06\x04\
    \x04\x04\0\x02\x03\x12\x03Q\x08\x18\x1aS\x20The\x20client\x20attempted\
    \x20to\x20authenticate\x20as\x20a\x20user\x20with\x20a\x20password\x20bu\
    t\x20it\n\x20was\x20wrong.\n\n\x0e\n\x07\x04\x04\x04\0\x02\x03\x01\x12\
    \x03Q\x08\x13\n\x0e\n\x07\x04\x04\x04\0\x02\x03\x02\x12\x03Q\x16\x17\nd\
    \n\x06\x04\x04\x04\0\x02\x04\x12\x03T\x08\x1a\x1aU\x20The\x20client\x20a\
    ttempted\x20to\x20connect\x20to\x20a\x20passworded\x20server\x20but\x20t\
    he\x20password\n\x20was\x20wrong.\n\n\x0e\n\x07\x04\x04\x04\0\x02\x04\
    \x01\x12\x03T\x08\x15\n\x0e\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x03T\x18\
    \x19\n5\n\x06\x04\x04\x04\0\x02\x05\x12\x03V\x08\x1a\x1a&\x20Supplied\
    \x20username\x20is\x20already\x20in\x20use.\n\n\x0e\n\x07\x04\x04\x04\0\
    \x02\x05\x01\x12\x03V\x08\x15\n\x0e\n\x07\x04\x04\x04\0\x02\x05\x02\x12\
    \x03V\x18\x19\nG\n\x06\x04\x04\x04\0\x02\x06\x12\x03X\x08\x17\x1a8\x20Se\
    rver\x20is\x20currently\x20full\x20and\x20cannot\x20accept\x20more\x20us\
    ers.\n\n\x0e\n\x07\x04\x04\x04\0\x02\x06\x01\x12\x03X\x08\x12\n\x0e\n\
    \x07\x04\x04\x04\0\x02\x06\x02\x12\x03X\x15\x16\nL\n\x06\x04\x04\x04\0\
    \x02\x07\x12\x03Z\x08\x1a\x1a=\x20The\x20user\x20did\x20not\x20provide\
    \x20a\x20certificate\x20but\x20one\x20is\x20required.\n\n\x0e\n\x07\x04\
    \x04\x04\0\x02\x07\x01\x12\x03Z\x08\x15\n\x0e\n\x07\x04\x04\x04\0\x02\
    \x07\x02\x12\x03Z\x18\x19\n\r\n\x06\x04\x04\x04\0\x02\x08\x12\x03[\x08\
    \x1e\n\x0e\n\x07\x04\x04\x04\0\x02\x08\x01\x12\x03[\x08\x19\n\x0e\n\x07\
    \x04\x04\x04\0\x02\x08\x02\x12\x03[\x1c\x1d\n\x1e\n\x04\x04\x04\x02\0\
    \x12\x03^\x04!\x1a\x11\x20Rejection\x20type.\n\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x03^\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03^\r\x17\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x03^\x18\x1c\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03^\x1f\x20\n/\n\x04\x04\x04\x02\x01\x12\x03`\x04\x1f\x1a\"\x20Hum\
    an\x20readable\x20rejection\x20reason.\n\n\x0c\n\x05\x04\x04\x02\x01\x04\
    \x12\x03`\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03`\r\x13\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x03`\x14\x1a\n\x0c\n\x05\x04\x04\x02\x01\
    \x03\x12\x03`\x1d\x1e\n\x87\x01\n\x02\x04\x05\x12\x04e\0n\x01\x1a{\x20Se\
    rverSync\x20message\x20is\x20sent\x20by\x20the\x20server\x20when\x20it\
    \x20has\x20authenticated\x20the\x20user\n\x20and\x20finished\x20synchron\
    izing\x20the\x20server\x20state.\n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\
    \x12\n/\n\x04\x04\x05\x02\0\x12\x03g\x04\x20\x1a\"\x20The\x20session\x20\
    of\x20the\x20current\x20user.\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03g\
    \x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03g\r\x13\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03g\x14\x1b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03g\
    \x1e\x1f\n:\n\x04\x04\x05\x02\x01\x12\x03i\x04&\x1a-\x20Maximum\x20bandw\
    idth\x20that\x20the\x20user\x20should\x20use.\n\n\x0c\n\x05\x04\x05\x02\
    \x01\x04\x12\x03i\x04\x0c\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03i\r\x13\
    \n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03i\x14!\n\x0c\n\x05\x04\x05\x02\
    \x01\x03\x12\x03i$%\n#\n\x04\x04\x05\x02\x02\x12\x03k\x04%\x1a\x16\x20Se\
    rver\x20welcome\x20text.\n\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03k\x04\
    \x0c\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03k\r\x13\n\x0c\n\x05\x04\x05\
    \x02\x02\x01\x12\x03k\x14\x20\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03k#$\
    \n<\n\x04\x04\x05\x02\x03\x12\x03m\x04$\x1a/\x20Current\x20user\x20permi\
    ssions\x20in\x20the\x20root\x20channel.\n\n\x0c\n\x05\x04\x05\x02\x03\
    \x04\x12\x03m\x04\x0c\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03m\r\x13\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03m\x14\x1f\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03m\"#\n\x96\x01\n\x02\x04\x06\x12\x04r\0t\x01\x1a\x89\x01\
    \x20Sent\x20by\x20the\x20client\x20when\x20it\x20wants\x20a\x20channel\
    \x20removed.\x20Sent\x20by\x20the\x20server\x20when\n\x20a\x20channel\
    \x20has\x20been\x20removed\x20and\x20clients\x20should\x20be\x20notified\
    .\n\n\n\n\x03\x04\x06\x01\x12\x03r\x08\x15\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03s\x04#\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03s\x04\x0c\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03s\r\x13\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03s\
    \x14\x1e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03s!\"\n\xee\x01\n\x02\x04\
    \x07\x12\x05y\0\x98\x01\x01\x1a\xe0\x01\x20Used\x20to\x20communicate\x20\
    channel\x20properties\x20between\x20the\x20client\x20and\x20the\x20serve\
    r.\n\x20Sent\x20by\x20the\x20server\x20during\x20the\x20login\x20process\
    \x20or\x20when\x20channel\x20properties\x20are\n\x20updated.\x20Client\
    \x20may\x20use\x20this\x20message\x20to\x20update\x20said\x20channel\x20\
    properties.\n\n\n\n\x03\x04\x07\x01\x12\x03y\x08\x14\n;\n\x04\x04\x07\
    \x02\0\x12\x03{\x04#\x1a.\x20Unique\x20ID\x20for\x20the\x20channel\x20wi\
    thin\x20the\x20server.\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03{\x04\x0c\
    \n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03{\r\x13\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03{\x14\x1e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03{!\"\n0\n\x04\
    \x04\x07\x02\x01\x12\x03}\x04\x1f\x1a#\x20channel_id\x20of\x20the\x20par\
    ent\x20channel.\n\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03}\x04\x0c\n\x0c\
    \n\x05\x04\x07\x02\x01\x05\x12\x03}\r\x13\n\x0c\n\x05\x04\x07\x02\x01\
    \x01\x12\x03}\x14\x1a\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03}\x1d\x1e\n\
    *\n\x04\x04\x07\x02\x02\x12\x03\x7f\x04\x1d\x1a\x1d\x20UTF-8\x20encoded\
    \x20channel\x20name.\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03\x7f\x04\
    \x0c\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03\x7f\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03\x7f\x14\x18\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03\x7f\x1b\x1c\ns\n\x04\x04\x07\x02\x03\x12\x04\x82\x01\x04\x1e\x1ae\
    \x20A\x20collection\x20of\x20channel\x20id\x20values\x20of\x20the\x20lin\
    ked\x20channels.\x20Absent\x20during\n\x20the\x20first\x20channel\x20lis\
    ting.\n\n\r\n\x05\x04\x07\x02\x03\x04\x12\x04\x82\x01\x04\x0c\n\r\n\x05\
    \x04\x07\x02\x03\x05\x12\x04\x82\x01\r\x13\n\r\n\x05\x04\x07\x02\x03\x01\
    \x12\x04\x82\x01\x14\x19\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\x82\x01\
    \x1c\x1d\nb\n\x04\x04\x07\x02\x04\x12\x04\x85\x01\x04$\x1aT\x20UTF-8\x20\
    encoded\x20channel\x20description.\x20Only\x20if\x20the\x20description\
    \x20is\x20less\x20than\n\x20128\x20bytes\n\n\r\n\x05\x04\x07\x02\x04\x04\
    \x12\x04\x85\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\x85\x01\r\
    \x13\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\x85\x01\x14\x1f\n\r\n\x05\x04\
    \x07\x02\x04\x03\x12\x04\x85\x01\"#\nP\n\x04\x04\x07\x02\x05\x12\x04\x87\
    \x01\x04\"\x1aB\x20A\x20collection\x20of\x20channel_id\x20values\x20that\
    \x20should\x20be\x20added\x20to\x20links.\n\n\r\n\x05\x04\x07\x02\x05\
    \x04\x12\x04\x87\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\x87\
    \x01\r\x13\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\x87\x01\x14\x1d\n\r\n\
    \x05\x04\x07\x02\x05\x03\x12\x04\x87\x01\x20!\nT\n\x04\x04\x07\x02\x06\
    \x12\x04\x89\x01\x04%\x1aF\x20A\x20collection\x20of\x20channel_id\x20val\
    ues\x20that\x20should\x20be\x20removed\x20from\x20links.\n\n\r\n\x05\x04\
    \x07\x02\x06\x04\x12\x04\x89\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x06\x05\
    \x12\x04\x89\x01\r\x13\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\x89\x01\x14\
    \x20\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\x89\x01#$\n1\n\x04\x04\x07\
    \x02\x07\x12\x04\x8b\x01\x042\x1a#\x20True\x20if\x20the\x20channel\x20is\
    \x20temporary.\n\n\r\n\x05\x04\x07\x02\x07\x04\x12\x04\x8b\x01\x04\x0c\n\
    \r\n\x05\x04\x07\x02\x07\x05\x12\x04\x8b\x01\r\x11\n\r\n\x05\x04\x07\x02\
    \x07\x01\x12\x04\x8b\x01\x12\x1b\n\r\n\x05\x04\x07\x02\x07\x03\x12\x04\
    \x8b\x01\x1e\x1f\n\r\n\x05\x04\x07\x02\x07\x08\x12\x04\x8b\x01\x201\n\r\
    \n\x05\x04\x07\x02\x07\x07\x12\x04\x8b\x01+0\nR\n\x04\x04\x07\x02\x08\
    \x12\x04\x8d\x01\x04.\x1aD\x20Position\x20weight\x20to\x20tweak\x20the\
    \x20channel\x20position\x20in\x20the\x20channel\x20list.\n\n\r\n\x05\x04\
    \x07\x02\x08\x04\x12\x04\x8d\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x08\x05\
    \x12\x04\x8d\x01\r\x12\n\r\n\x05\x04\x07\x02\x08\x01\x12\x04\x8d\x01\x13\
    \x1b\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\x8d\x01\x1e\x1f\n\r\n\x05\x04\
    \x07\x02\x08\x08\x12\x04\x8d\x01\x20-\n\r\n\x05\x04\x07\x02\x08\x07\x12\
    \x04\x8d\x01+,\nU\n\x04\x04\x07\x02\t\x12\x04\x8f\x01\x04)\x1aG\x20SHA1\
    \x20hash\x20of\x20the\x20description\x20if\x20the\x20description\x20is\
    \x20128\x20bytes\x20or\x20more.\n\n\r\n\x05\x04\x07\x02\t\x04\x12\x04\
    \x8f\x01\x04\x0c\n\r\n\x05\x04\x07\x02\t\x05\x12\x04\x8f\x01\r\x12\n\r\n\
    \x05\x04\x07\x02\t\x01\x12\x04\x8f\x01\x13#\n\r\n\x05\x04\x07\x02\t\x03\
    \x12\x04\x8f\x01&(\n\xc0\x01\n\x04\x04\x07\x02\n\x12\x04\x93\x01\x04#\
    \x1a\xb1\x01\x20Maximum\x20number\x20of\x20users\x20allowed\x20in\x20the\
    \x20channel.\x20If\x20this\x20value\x20is\x20zero,\n\x20the\x20maximum\
    \x20number\x20of\x20users\x20allowed\x20in\x20the\x20channel\x20is\x20gi\
    ven\x20by\x20the\n\x20server's\x20\"usersperchannel\"\x20setting.\n\n\r\
    \n\x05\x04\x07\x02\n\x04\x12\x04\x93\x01\x04\x0c\n\r\n\x05\x04\x07\x02\n\
    \x05\x12\x04\x93\x01\r\x13\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\x93\x01\
    \x14\x1d\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\x93\x01\x20\"\nS\n\x04\x04\
    \x07\x02\x0b\x12\x04\x95\x01\x04+\x1aE\x20Whether\x20this\x20channel\x20\
    has\x20enter\x20restrictions\x20(ACL\x20denying\x20ENTER)\x20set\n\n\r\n\
    \x05\x04\x07\x02\x0b\x04\x12\x04\x95\x01\x04\x0c\n\r\n\x05\x04\x07\x02\
    \x0b\x05\x12\x04\x95\x01\r\x11\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\x95\
    \x01\x12%\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\x95\x01(*\n_\n\x04\x04\
    \x07\x02\x0c\x12\x04\x97\x01\x04!\x1aQ\x20Whether\x20the\x20receiver\x20\
    of\x20this\x20msg\x20is\x20considered\x20to\x20be\x20able\x20to\x20enter\
    \x20this\x20channel\n\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\x97\x01\x04\
    \x0c\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\x97\x01\r\x11\n\r\n\x05\x04\
    \x07\x02\x0c\x01\x12\x04\x97\x01\x12\x1b\n\r\n\x05\x04\x07\x02\x0c\x03\
    \x12\x04\x97\x01\x1e\x20\n\xd2\x01\n\x02\x04\x08\x12\x06\x9d\x01\0\xa8\
    \x01\x01\x1a\xc3\x01\x20Used\x20to\x20communicate\x20user\x20leaving\x20\
    or\x20being\x20kicked.\x20May\x20be\x20sent\x20by\x20the\x20client\n\x20\
    when\x20it\x20attempts\x20to\x20kick\x20a\x20user.\x20Sent\x20by\x20the\
    \x20server\x20when\x20it\x20informs\x20the\n\x20clients\x20that\x20a\x20\
    user\x20is\x20not\x20present\x20anymore.\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\x9d\x01\x08\x12\nt\n\x04\x04\x08\x02\0\x12\x04\xa0\x01\x04\x20\x1af\
    \x20The\x20user\x20who\x20is\x20being\x20kicked,\x20identified\x20by\x20\
    their\x20session,\x20not\x20present\n\x20when\x20no\x20one\x20is\x20bein\
    g\x20kicked.\n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xa0\x01\x04\x0c\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\xa0\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\
    \x12\x04\xa0\x01\x14\x1b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa0\x01\x1e\
    \x1f\n\x80\x01\n\x04\x04\x08\x02\x01\x12\x04\xa3\x01\x04\x1e\x1ar\x20The\
    \x20user\x20who\x20initiated\x20the\x20removal.\x20Either\x20the\x20user\
    \x20who\x20performs\x20the\x20kick\n\x20or\x20the\x20user\x20who\x20is\
    \x20currently\x20leaving.\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xa3\
    \x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa3\x01\r\x13\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\xa3\x01\x14\x19\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xa3\x01\x1c\x1d\nT\n\x04\x04\x08\x02\x02\x12\x04\xa5\
    \x01\x04\x1f\x1aF\x20Reason\x20for\x20the\x20kick,\x20stored\x20as\x20th\
    e\x20ban\x20reason\x20if\x20the\x20user\x20is\x20banned.\n\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04\xa5\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\xa5\x01\r\x13\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xa5\x01\x14\
    \x1a\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xa5\x01\x1d\x1e\n8\n\x04\x04\
    \x08\x02\x03\x12\x04\xa7\x01\x04\x1a\x1a*\x20True\x20if\x20the\x20kick\
    \x20should\x20result\x20in\x20a\x20ban.\n\n\r\n\x05\x04\x08\x02\x03\x04\
    \x12\x04\xa7\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xa7\x01\r\
    \x11\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xa7\x01\x12\x15\n\r\n\x05\x04\
    \x08\x02\x03\x03\x12\x04\xa7\x01\x18\x19\n\xbb\x01\n\x02\x04\t\x12\x06\
    \xad\x01\0\xe1\x01\x01\x1a\xac\x01\x20Sent\x20by\x20the\x20server\x20whe\
    n\x20it\x20communicates\x20new\x20and\x20changed\x20users\x20to\x20clien\
    t.\n\x20First\x20seen\x20during\x20login\x20procedure.\x20May\x20be\x20s\
    ent\x20by\x20the\x20client\x20when\x20it\x20wishes\n\x20to\x20alter\x20i\
    ts\x20state.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xad\x01\x08\x11\na\n\x04\
    \x04\t\x02\0\x12\x04\xb0\x01\x04\x20\x1aS\x20Unique\x20user\x20session\
    \x20ID\x20of\x20the\x20user\x20whose\x20state\x20this\x20is,\x20may\x20c\
    hange\x20on\n\x20reconnect.\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xb0\x01\
    \x04\x0c\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xb0\x01\r\x13\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\xb0\x01\x14\x1b\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xb0\
    \x01\x1e\x1f\nB\n\x04\x04\t\x02\x01\x12\x04\xb2\x01\x04\x1e\x1a4\x20The\
    \x20session\x20of\x20the\x20user\x20who\x20is\x20updating\x20this\x20use\
    r.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xb2\x01\x04\x0c\n\r\n\x05\x04\t\
    \x02\x01\x05\x12\x04\xb2\x01\r\x13\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\
    \xb2\x01\x14\x19\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xb2\x01\x1c\x1d\n)\
    \n\x04\x04\t\x02\x02\x12\x04\xb4\x01\x04\x1d\x1a\x1b\x20User\x20name,\
    \x20UTF-8\x20encoded.\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xb4\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xb4\x01\r\x13\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\xb4\x01\x14\x18\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \xb4\x01\x1b\x1c\n=\n\x04\x04\t\x02\x03\x12\x04\xb6\x01\x04\x20\x1a/\x20\
    Registered\x20user\x20ID\x20if\x20the\x20user\x20is\x20registered.\n\n\r\
    \n\x05\x04\t\x02\x03\x04\x12\x04\xb6\x01\x04\x0c\n\r\n\x05\x04\t\x02\x03\
    \x05\x12\x04\xb6\x01\r\x13\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xb6\x01\
    \x14\x1b\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xb6\x01\x1e\x1f\n-\n\x04\
    \x04\t\x02\x04\x12\x04\xb8\x01\x04#\x1a\x1f\x20Channel\x20on\x20which\
    \x20the\x20user\x20is.\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xb8\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xb8\x01\r\x13\n\r\n\x05\x04\t\
    \x02\x04\x01\x12\x04\xb8\x01\x14\x1e\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\
    \xb8\x01!\"\n3\n\x04\x04\t\x02\x05\x12\x04\xba\x01\x04\x1b\x1a%\x20True\
    \x20if\x20the\x20user\x20is\x20muted\x20by\x20admin.\n\n\r\n\x05\x04\t\
    \x02\x05\x04\x12\x04\xba\x01\x04\x0c\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\
    \xba\x01\r\x11\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xba\x01\x12\x16\n\r\n\
    \x05\x04\t\x02\x05\x03\x12\x04\xba\x01\x19\x1a\n6\n\x04\x04\t\x02\x06\
    \x12\x04\xbc\x01\x04\x1b\x1a(\x20True\x20if\x20the\x20user\x20is\x20deaf\
    ened\x20by\x20admin.\n\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\xbc\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xbc\x01\r\x11\n\r\n\x05\x04\t\
    \x02\x06\x01\x12\x04\xbc\x01\x12\x16\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\
    \xbc\x01\x19\x1a\nf\n\x04\x04\t\x02\x07\x12\x04\xbf\x01\x04\x1f\x1aX\x20\
    True\x20if\x20the\x20user\x20has\x20been\x20suppressed\x20from\x20talkin\
    g\x20by\x20a\x20reason\x20other\x20than\n\x20being\x20muted.\n\n\r\n\x05\
    \x04\t\x02\x07\x04\x12\x04\xbf\x01\x04\x0c\n\r\n\x05\x04\t\x02\x07\x05\
    \x12\x04\xbf\x01\r\x11\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xbf\x01\x12\
    \x1a\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xbf\x01\x1d\x1e\n0\n\x04\x04\t\
    \x02\x08\x12\x04\xc1\x01\x04\x20\x1a\"\x20True\x20if\x20the\x20user\x20h\
    as\x20muted\x20self.\n\n\r\n\x05\x04\t\x02\x08\x04\x12\x04\xc1\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x08\x05\x12\x04\xc1\x01\r\x11\n\r\n\x05\x04\t\
    \x02\x08\x01\x12\x04\xc1\x01\x12\x1b\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\
    \xc1\x01\x1e\x1f\n3\n\x04\x04\t\x02\t\x12\x04\xc3\x01\x04!\x1a%\x20True\
    \x20if\x20the\x20user\x20has\x20deafened\x20self.\n\n\r\n\x05\x04\t\x02\
    \t\x04\x12\x04\xc3\x01\x04\x0c\n\r\n\x05\x04\t\x02\t\x05\x12\x04\xc3\x01\
    \r\x11\n\r\n\x05\x04\t\x02\t\x01\x12\x04\xc3\x01\x12\x1b\n\r\n\x05\x04\t\
    \x02\t\x03\x12\x04\xc3\x01\x1e\x20\n8\n\x04\x04\t\x02\n\x12\x04\xc5\x01\
    \x04\x20\x1a*\x20User\x20image\x20if\x20it\x20is\x20less\x20than\x20128\
    \x20bytes.\n\n\r\n\x05\x04\t\x02\n\x04\x12\x04\xc5\x01\x04\x0c\n\r\n\x05\
    \x04\t\x02\n\x05\x12\x04\xc5\x01\r\x12\n\r\n\x05\x04\t\x02\n\x01\x12\x04\
    \xc5\x01\x13\x1a\n\r\n\x05\x04\t\x02\n\x03\x12\x04\xc5\x01\x1d\x1f\n\xbe\
    \x01\n\x04\x04\t\x02\x0b\x12\x04\xcb\x01\x04'\x1a\xaf\x01\x20The\x20posi\
    tional\x20audio\x20plugin\x20identifier.\n\x20Positional\x20audio\x20inf\
    ormation\x20is\x20only\x20sent\x20to\x20users\x20who\x20share\n\x20ident\
    ical\x20plugin\x20contexts.\n\n\x20This\x20value\x20is\x20not\x20transmi\
    tted\x20to\x20clients.\n\n\r\n\x05\x04\t\x02\x0b\x04\x12\x04\xcb\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x0b\x05\x12\x04\xcb\x01\r\x12\n\r\n\x05\x04\t\
    \x02\x0b\x01\x12\x04\xcb\x01\x13!\n\r\n\x05\x04\t\x02\x0b\x03\x12\x04\
    \xcb\x01$&\n_\n\x04\x04\t\x02\x0c\x12\x04\xce\x01\x04)\x1aQ\x20The\x20us\
    er's\x20plugin-specific\x20identity.\n\x20This\x20value\x20is\x20not\x20\
    transmitted\x20to\x20clients.\n\n\r\n\x05\x04\t\x02\x0c\x04\x12\x04\xce\
    \x01\x04\x0c\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\xce\x01\r\x13\n\r\n\x05\
    \x04\t\x02\x0c\x01\x12\x04\xce\x01\x14#\n\r\n\x05\x04\t\x02\x0c\x03\x12\
    \x04\xce\x01&(\n:\n\x04\x04\t\x02\r\x12\x04\xd0\x01\x04!\x1a,\x20User\
    \x20comment\x20if\x20it\x20is\x20less\x20than\x20128\x20bytes.\n\n\r\n\
    \x05\x04\t\x02\r\x04\x12\x04\xd0\x01\x04\x0c\n\r\n\x05\x04\t\x02\r\x05\
    \x12\x04\xd0\x01\r\x13\n\r\n\x05\x04\t\x02\r\x01\x12\x04\xd0\x01\x14\x1b\
    \n\r\n\x05\x04\t\x02\r\x03\x12\x04\xd0\x01\x1e\x20\n1\n\x04\x04\t\x02\
    \x0e\x12\x04\xd2\x01\x04\x1e\x1a#\x20The\x20hash\x20of\x20the\x20user\
    \x20certificate.\n\n\r\n\x05\x04\t\x02\x0e\x04\x12\x04\xd2\x01\x04\x0c\n\
    \r\n\x05\x04\t\x02\x0e\x05\x12\x04\xd2\x01\r\x13\n\r\n\x05\x04\t\x02\x0e\
    \x01\x12\x04\xd2\x01\x14\x18\n\r\n\x05\x04\t\x02\x0e\x03\x12\x04\xd2\x01\
    \x1b\x1d\nF\n\x04\x04\t\x02\x0f\x12\x04\xd4\x01\x04%\x1a8\x20SHA1\x20has\
    h\x20of\x20the\x20user\x20comment\x20if\x20it\x20128\x20bytes\x20or\x20m\
    ore.\n\n\r\n\x05\x04\t\x02\x0f\x04\x12\x04\xd4\x01\x04\x0c\n\r\n\x05\x04\
    \t\x02\x0f\x05\x12\x04\xd4\x01\r\x12\n\r\n\x05\x04\t\x02\x0f\x01\x12\x04\
    \xd4\x01\x13\x1f\n\r\n\x05\x04\t\x02\x0f\x03\x12\x04\xd4\x01\"$\nF\n\x04\
    \x04\t\x02\x10\x12\x04\xd6\x01\x04%\x1a8\x20SHA1\x20hash\x20of\x20the\
    \x20user\x20picture\x20if\x20it\x20128\x20bytes\x20or\x20more.\n\n\r\n\
    \x05\x04\t\x02\x10\x04\x12\x04\xd6\x01\x04\x0c\n\r\n\x05\x04\t\x02\x10\
    \x05\x12\x04\xd6\x01\r\x12\n\r\n\x05\x04\t\x02\x10\x01\x12\x04\xd6\x01\
    \x13\x1f\n\r\n\x05\x04\t\x02\x10\x03\x12\x04\xd6\x01\"$\n7\n\x04\x04\t\
    \x02\x11\x12\x04\xd8\x01\x04(\x1a)\x20True\x20if\x20the\x20user\x20is\
    \x20a\x20priority\x20speaker.\n\n\r\n\x05\x04\t\x02\x11\x04\x12\x04\xd8\
    \x01\x04\x0c\n\r\n\x05\x04\t\x02\x11\x05\x12\x04\xd8\x01\r\x11\n\r\n\x05\
    \x04\t\x02\x11\x01\x12\x04\xd8\x01\x12\"\n\r\n\x05\x04\t\x02\x11\x03\x12\
    \x04\xd8\x01%'\n8\n\x04\x04\t\x02\x12\x12\x04\xda\x01\x04!\x1a*\x20True\
    \x20if\x20the\x20user\x20is\x20currently\x20recording.\n\n\r\n\x05\x04\t\
    \x02\x12\x04\x12\x04\xda\x01\x04\x0c\n\r\n\x05\x04\t\x02\x12\x05\x12\x04\
    \xda\x01\r\x11\n\r\n\x05\x04\t\x02\x12\x01\x12\x04\xda\x01\x12\x1b\n\r\n\
    \x05\x04\t\x02\x12\x03\x12\x04\xda\x01\x1e\x20\n_\n\x04\x04\t\x02\x13\
    \x12\x04\xdc\x01\x041\x1aQ\x20A\x20list\x20of\x20temporary\x20access\x20\
    tokens\x20to\x20be\x20respected\x20when\x20processing\x20this\x20request\
    .\n\n\r\n\x05\x04\t\x02\x13\x04\x12\x04\xdc\x01\x04\x0c\n\r\n\x05\x04\t\
    \x02\x13\x05\x12\x04\xdc\x01\r\x13\n\r\n\x05\x04\t\x02\x13\x01\x12\x04\
    \xdc\x01\x14+\n\r\n\x05\x04\t\x02\x13\x03\x12\x04\xdc\x01.0\nH\n\x04\x04\
    \t\x02\x14\x12\x04\xde\x01\x04/\x1a:\x20A\x20list\x20of\x20channels\x20t\
    he\x20user\x20wants\x20to\x20start\x20listening\x20to.\n\n\r\n\x05\x04\t\
    \x02\x14\x04\x12\x04\xde\x01\x04\x0c\n\r\n\x05\x04\t\x02\x14\x05\x12\x04\
    \xde\x01\r\x13\n\r\n\x05\x04\t\x02\x14\x01\x12\x04\xde\x01\x14)\n\r\n\
    \x05\x04\t\x02\x14\x03\x12\x04\xde\x01,.\nM\n\x04\x04\t\x02\x15\x12\x04\
    \xe0\x01\x042\x1a?\x20a\x20list\x20of\x20channels\x20the\x20user\x20does\
    \x20no\x20longer\x20want\x20to\x20listen\x20to.\n\n\r\n\x05\x04\t\x02\
    \x15\x04\x12\x04\xe0\x01\x04\x0c\n\r\n\x05\x04\t\x02\x15\x05\x12\x04\xe0\
    \x01\r\x13\n\r\n\x05\x04\t\x02\x15\x01\x12\x04\xe0\x01\x14,\n\r\n\x05\
    \x04\t\x02\x15\x03\x12\x04\xe0\x01/1\n\xda\x01\n\x02\x04\n\x12\x06\xe6\
    \x01\0\xfc\x01\x01\x1a\xcb\x01\x20Relays\x20information\x20on\x20the\x20\
    bans.\x20The\x20client\x20may\x20send\x20the\x20BanList\x20message\x20to\
    \n\x20either\x20modify\x20the\x20list\x20of\x20bans\x20or\x20query\x20th\
    em\x20from\x20the\x20server.\x20The\x20server\n\x20sends\x20this\x20list\
    \x20only\x20after\x20a\x20client\x20queries\x20for\x20it.\n\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xe6\x01\x08\x0f\n\x0e\n\x04\x04\n\x03\0\x12\x06\xe7\
    \x01\x04\xf6\x01\x05\n\r\n\x05\x04\n\x03\0\x01\x12\x04\xe7\x01\x0c\x14\n\
    $\n\x06\x04\n\x03\0\x02\0\x12\x04\xe9\x01\x08#\x1a\x14\x20Banned\x20IP\
    \x20address.\n\n\x0f\n\x07\x04\n\x03\0\x02\0\x04\x12\x04\xe9\x01\x08\x10\
    \n\x0f\n\x07\x04\n\x03\0\x02\0\x05\x12\x04\xe9\x01\x11\x16\n\x0f\n\x07\
    \x04\n\x03\0\x02\0\x01\x12\x04\xe9\x01\x17\x1e\n\x0f\n\x07\x04\n\x03\0\
    \x02\0\x03\x12\x04\xe9\x01!\"\n<\n\x06\x04\n\x03\0\x02\x01\x12\x04\xeb\
    \x01\x08!\x1a,\x20The\x20length\x20of\x20the\x20subnet\x20mask\x20for\
    \x20the\x20ban.\n\n\x0f\n\x07\x04\n\x03\0\x02\x01\x04\x12\x04\xeb\x01\
    \x08\x10\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\x12\x04\xeb\x01\x11\x17\n\
    \x0f\n\x07\x04\n\x03\0\x02\x01\x01\x12\x04\xeb\x01\x18\x1c\n\x0f\n\x07\
    \x04\n\x03\0\x02\x01\x03\x12\x04\xeb\x01\x1f\x20\nR\n\x06\x04\n\x03\0\
    \x02\x02\x12\x04\xed\x01\x08!\x1aB\x20User\x20name\x20for\x20identificat\
    ion\x20purposes\x20(does\x20not\x20affect\x20the\x20ban).\n\n\x0f\n\x07\
    \x04\n\x03\0\x02\x02\x04\x12\x04\xed\x01\x08\x10\n\x0f\n\x07\x04\n\x03\0\
    \x02\x02\x05\x12\x04\xed\x01\x11\x17\n\x0f\n\x07\x04\n\x03\0\x02\x02\x01\
    \x12\x04\xed\x01\x18\x1c\n\x0f\n\x07\x04\n\x03\0\x02\x02\x03\x12\x04\xed\
    \x01\x1f\x20\n:\n\x06\x04\n\x03\0\x02\x03\x12\x04\xef\x01\x08!\x1a*\x20T\
    he\x20certificate\x20hash\x20of\x20the\x20banned\x20user.\n\n\x0f\n\x07\
    \x04\n\x03\0\x02\x03\x04\x12\x04\xef\x01\x08\x10\n\x0f\n\x07\x04\n\x03\0\
    \x02\x03\x05\x12\x04\xef\x01\x11\x17\n\x0f\n\x07\x04\n\x03\0\x02\x03\x01\
    \x12\x04\xef\x01\x18\x1c\n\x0f\n\x07\x04\n\x03\0\x02\x03\x03\x12\x04\xef\
    \x01\x1f\x20\n?\n\x06\x04\n\x03\0\x02\x04\x12\x04\xf1\x01\x08#\x1a/\x20R\
    eason\x20for\x20the\x20ban\x20(does\x20not\x20affect\x20the\x20ban).\n\n\
    \x0f\n\x07\x04\n\x03\0\x02\x04\x04\x12\x04\xf1\x01\x08\x10\n\x0f\n\x07\
    \x04\n\x03\0\x02\x04\x05\x12\x04\xf1\x01\x11\x17\n\x0f\n\x07\x04\n\x03\0\
    \x02\x04\x01\x12\x04\xf1\x01\x18\x1e\n\x0f\n\x07\x04\n\x03\0\x02\x04\x03\
    \x12\x04\xf1\x01!\"\n!\n\x06\x04\n\x03\0\x02\x05\x12\x04\xf3\x01\x08\"\
    \x1a\x11\x20Ban\x20start\x20time.\n\n\x0f\n\x07\x04\n\x03\0\x02\x05\x04\
    \x12\x04\xf3\x01\x08\x10\n\x0f\n\x07\x04\n\x03\0\x02\x05\x05\x12\x04\xf3\
    \x01\x11\x17\n\x0f\n\x07\x04\n\x03\0\x02\x05\x01\x12\x04\xf3\x01\x18\x1d\
    \n\x0f\n\x07\x04\n\x03\0\x02\x05\x03\x12\x04\xf3\x01\x20!\n*\n\x06\x04\n\
    \x03\0\x02\x06\x12\x04\xf5\x01\x08%\x1a\x1a\x20Ban\x20duration\x20in\x20\
    seconds.\n\n\x0f\n\x07\x04\n\x03\0\x02\x06\x04\x12\x04\xf5\x01\x08\x10\n\
    \x0f\n\x07\x04\n\x03\0\x02\x06\x05\x12\x04\xf5\x01\x11\x17\n\x0f\n\x07\
    \x04\n\x03\0\x02\x06\x01\x12\x04\xf5\x01\x18\x20\n\x0f\n\x07\x04\n\x03\0\
    \x02\x06\x03\x12\x04\xf5\x01#$\n7\n\x04\x04\n\x02\0\x12\x04\xf8\x01\x04\
    \x1f\x1a)\x20List\x20of\x20ban\x20entries\x20currently\x20in\x20place.\n\
    \n\r\n\x05\x04\n\x02\0\x04\x12\x04\xf8\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\
    \x06\x12\x04\xf8\x01\r\x15\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xf8\x01\x16\
    \x1a\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xf8\x01\x1d\x1e\nz\n\x04\x04\n\
    \x02\x01\x12\x04\xfb\x01\x04.\x1al\x20True\x20if\x20the\x20server\x20sho\
    uld\x20return\x20the\x20list,\x20false\x20if\x20it\x20should\x20replace\
    \x20old\n\x20ban\x20list\x20with\x20the\x20one\x20provided.\n\n\r\n\x05\
    \x04\n\x02\x01\x04\x12\x04\xfb\x01\x04\x0c\n\r\n\x05\x04\n\x02\x01\x05\
    \x12\x04\xfb\x01\r\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xfb\x01\x12\
    \x17\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xfb\x01\x1a\x1b\n\r\n\x05\x04\n\
    \x02\x01\x08\x12\x04\xfb\x01\x1c-\n\r\n\x05\x04\n\x02\x01\x07\x12\x04\
    \xfb\x01',\n9\n\x02\x04\x0b\x12\x06\xff\x01\0\x8c\x02\x01\x1a+\x20Used\
    \x20to\x20send\x20and\x20broadcast\x20text\x20messages.\n\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xff\x01\x08\x13\n>\n\x04\x04\x0b\x02\0\x12\x04\x81\
    \x02\x04\x1e\x1a0\x20The\x20message\x20sender,\x20identified\x20by\x20it\
    s\x20session.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x81\x02\x04\x0c\n\r\
    \n\x05\x04\x0b\x02\0\x05\x12\x04\x81\x02\r\x13\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x81\x02\x14\x19\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x81\x02\
    \x1c\x1d\nJ\n\x04\x04\x0b\x02\x01\x12\x04\x83\x02\x04\x20\x1a<\x20Target\
    \x20users\x20for\x20the\x20message,\x20identified\x20by\x20their\x20sess\
    ion.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x83\x02\x04\x0c\n\r\n\x05\
    \x04\x0b\x02\x01\x05\x12\x04\x83\x02\r\x13\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\x83\x02\x14\x1b\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x83\x02\
    \x1e\x1f\n\\\n\x04\x04\x0b\x02\x02\x12\x04\x86\x02\x04#\x1aN\x20The\x20c\
    hannels\x20to\x20which\x20the\x20message\x20is\x20sent,\x20identified\
    \x20by\x20their\n\x20channel_ids.\n\n\r\n\x05\x04\x0b\x02\x02\x04\x12\
    \x04\x86\x02\x04\x0c\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x86\x02\r\x13\
    \n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x86\x02\x14\x1e\n\r\n\x05\x04\x0b\
    \x02\x02\x03\x12\x04\x86\x02!\"\ny\n\x04\x04\x0b\x02\x03\x12\x04\x89\x02\
    \x04\x20\x1ak\x20The\x20root\x20channels\x20when\x20sending\x20message\
    \x20recursively\x20to\x20several\x20channels,\n\x20identified\x20by\x20t\
    heir\x20channel_ids.\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x89\x02\x04\
    \x0c\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\x89\x02\r\x13\n\r\n\x05\x04\
    \x0b\x02\x03\x01\x12\x04\x89\x02\x14\x1b\n\r\n\x05\x04\x0b\x02\x03\x03\
    \x12\x04\x89\x02\x1e\x1f\nL\n\x04\x04\x0b\x02\x04\x12\x04\x8b\x02\x04\
    \x20\x1a>\x20The\x20UTF-8\x20encoded\x20message.\x20May\x20be\x20HTML\
    \x20if\x20the\x20server\x20allows.\n\n\r\n\x05\x04\x0b\x02\x04\x04\x12\
    \x04\x8b\x02\x04\x0c\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x8b\x02\r\x13\
    \n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x8b\x02\x14\x1b\n\r\n\x05\x04\x0b\
    \x02\x04\x03\x12\x04\x8b\x02\x1e\x1f\n\x0c\n\x02\x04\x0c\x12\x06\x8e\x02\
    \0\xba\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8e\x02\x08\x18\n\x0e\n\
    \x04\x04\x0c\x04\0\x12\x06\x8f\x02\x04\xac\x02\x05\n\r\n\x05\x04\x0c\x04\
    \0\x01\x12\x04\x8f\x02\t\x11\nF\n\x06\x04\x0c\x04\0\x02\0\x12\x04\x91\
    \x02\x08\x11\x1a6\x20Operation\x20denied\x20for\x20other\x20reason,\x20s\
    ee\x20reason\x20field.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\0\x01\x12\x04\x91\
    \x02\x08\x0c\n\x0f\n\x07\x04\x0c\x04\0\x02\0\x02\x12\x04\x91\x02\x0f\x10\
    \n*\n\x06\x04\x0c\x04\0\x02\x01\x12\x04\x93\x02\x08\x17\x1a\x1a\x20Permi\
    ssions\x20were\x20denied.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x01\x12\
    \x04\x93\x02\x08\x12\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x04\x93\
    \x02\x15\x16\n*\n\x06\x04\x0c\x04\0\x02\x02\x12\x04\x95\x02\x08\x16\x1a\
    \x1a\x20Cannot\x20modify\x20SuperUser.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\
    \x02\x01\x12\x04\x95\x02\x08\x11\n\x0f\n\x07\x04\x0c\x04\0\x02\x02\x02\
    \x12\x04\x95\x02\x14\x15\n'\n\x06\x04\x0c\x04\0\x02\x03\x12\x04\x97\x02\
    \x08\x18\x1a\x17\x20Invalid\x20channel\x20name.\n\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\x03\x01\x12\x04\x97\x02\x08\x13\n\x0f\n\x07\x04\x0c\x04\0\x02\
    \x03\x02\x12\x04\x97\x02\x16\x17\n(\n\x06\x04\x0c\x04\0\x02\x04\x12\x04\
    \x99\x02\x08\x18\x1a\x18\x20Text\x20message\x20too\x20long.\n\n\x0f\n\
    \x07\x04\x0c\x04\0\x02\x04\x01\x12\x04\x99\x02\x08\x13\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\x04\x02\x12\x04\x99\x02\x16\x17\n7\n\x06\x04\x0c\x04\0\
    \x02\x05\x12\x04\x9b\x02\x08\x10\x1a'\x20The\x20flux\x20capacitor\x20was\
    \x20spelled\x20wrong.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\x05\x01\x12\x04\
    \x9b\x02\x08\x0b\n\x0f\n\x07\x04\x0c\x04\0\x02\x05\x02\x12\x04\x9b\x02\
    \x0e\x0f\n?\n\x06\x04\x0c\x04\0\x02\x06\x12\x04\x9d\x02\x08\x1d\x1a/\x20\
    Operation\x20not\x20permitted\x20in\x20temporary\x20channel.\n\n\x0f\n\
    \x07\x04\x0c\x04\0\x02\x06\x01\x12\x04\x9d\x02\x08\x18\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\x06\x02\x12\x04\x9d\x02\x1b\x1c\n1\n\x06\x04\x0c\x04\0\
    \x02\x07\x12\x04\x9f\x02\x08\x1f\x1a!\x20Operation\x20requires\x20certif\
    icate.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\x07\x01\x12\x04\x9f\x02\x08\x1a\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x07\x02\x12\x04\x9f\x02\x1d\x1e\n#\n\x06\
    \x04\x0c\x04\0\x02\x08\x12\x04\xa1\x02\x08\x15\x1a\x13\x20Invalid\x20use\
    rname.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\x08\x01\x12\x04\xa1\x02\x08\x10\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x08\x02\x12\x04\xa1\x02\x13\x14\n\"\n\x06\
    \x04\x0c\x04\0\x02\t\x12\x04\xa3\x02\x08\x18\x1a\x12\x20Channel\x20is\
    \x20full.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\t\x01\x12\x04\xa3\x02\x08\x13\
    \n\x0f\n\x07\x04\x0c\x04\0\x02\t\x02\x12\x04\xa3\x02\x16\x17\n1\n\x06\
    \x04\x0c\x04\0\x02\n\x12\x04\xa5\x02\x08\x1a\x1a!\x20Channels\x20are\x20\
    nested\x20too\x20deeply.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\n\x01\x12\x04\
    \xa5\x02\x08\x14\n\x0f\n\x07\x04\x0c\x04\0\x02\n\x02\x12\x04\xa5\x02\x17\
    \x19\n0\n\x06\x04\x0c\x04\0\x02\x0b\x12\x04\xa7\x02\x08\x1f\x1a\x20\x20M\
    aximum\x20channel\x20count\x20reached.\n\n\x0f\n\x07\x04\x0c\x04\0\x02\
    \x0b\x01\x12\x04\xa7\x02\x08\x19\n\x0f\n\x07\x04\x0c\x04\0\x02\x0b\x02\
    \x12\x04\xa7\x02\x1c\x1e\nN\n\x06\x04\x0c\x04\0\x02\x0c\x12\x04\xa9\x02\
    \x08\"\x1a>\x20Amount\x20of\x20listener\x20objects\x20for\x20this\x20cha\
    nnel\x20has\x20been\x20reached\n\n\x0f\n\x07\x04\x0c\x04\0\x02\x0c\x01\
    \x12\x04\xa9\x02\x08\x1c\n\x0f\n\x07\x04\x0c\x04\0\x02\x0c\x02\x12\x04\
    \xa9\x02\x1f!\nJ\n\x06\x04\x0c\x04\0\x02\r\x12\x04\xab\x02\x08\x1f\x1a:\
    \x20Amount\x20of\x20listener\x20proxies\x20for\x20the\x20user\x20has\x20\
    been\x20reached\n\n\x0f\n\x07\x04\x0c\x04\0\x02\r\x01\x12\x04\xab\x02\
    \x08\x19\n\x0f\n\x07\x04\x0c\x04\0\x02\r\x02\x12\x04\xab\x02\x1c\x1e\n>\
    \n\x04\x04\x0c\x02\0\x12\x04\xae\x02\x04#\x1a0\x20The\x20denied\x20permi\
    ssion\x20when\x20type\x20is\x20Permission.\n\n\r\n\x05\x04\x0c\x02\0\x04\
    \x12\x04\xae\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xae\x02\r\
    \x13\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xae\x02\x14\x1e\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\xae\x02!\"\nd\n\x04\x04\x0c\x02\x01\x12\x04\xb1\
    \x02\x04#\x1aV\x20channel_id\x20for\x20the\x20channel\x20where\x20the\
    \x20permission\x20was\x20denied\x20when\x20type\x20is\n\x20Permission.\n\
    \n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xb1\x02\x04\x0c\n\r\n\x05\x04\x0c\
    \x02\x01\x05\x12\x04\xb1\x02\r\x13\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \xb1\x02\x14\x1e\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xb1\x02!\"\nK\n\
    \x04\x04\x0c\x02\x02\x12\x04\xb3\x02\x04\x20\x1a=\x20The\x20user\x20who\
    \x20was\x20denied\x20permissions,\x20identified\x20by\x20session.\n\n\r\
    \n\x05\x04\x0c\x02\x02\x04\x12\x04\xb3\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x02\x05\x12\x04\xb3\x02\r\x13\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xb3\
    \x02\x14\x1b\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb3\x02\x1e\x1f\n.\n\
    \x04\x04\x0c\x02\x03\x12\x04\xb5\x02\x04\x1f\x1a\x20\x20Textual\x20reaso\
    n\x20for\x20the\x20denial.\n\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\xb5\
    \x02\x04\x0c\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xb5\x02\r\x13\n\r\n\
    \x05\x04\x0c\x02\x03\x01\x12\x04\xb5\x02\x14\x1a\n\r\n\x05\x04\x0c\x02\
    \x03\x03\x12\x04\xb5\x02\x1d\x1e\n#\n\x04\x04\x0c\x02\x04\x12\x04\xb7\
    \x02\x04\x1f\x1a\x15\x20Type\x20of\x20the\x20denial.\n\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04\xb7\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\x04\x06\x12\
    \x04\xb7\x02\r\x15\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xb7\x02\x16\x1a\
    \n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xb7\x02\x1d\x1e\n?\n\x04\x04\x0c\
    \x02\x05\x12\x04\xb9\x02\x04\x1d\x1a1\x20The\x20name\x20that\x20is\x20in\
    valid\x20when\x20type\x20is\x20UserName.\n\n\r\n\x05\x04\x0c\x02\x05\x04\
    \x12\x04\xb9\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xb9\x02\r\
    \x13\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xb9\x02\x14\x18\n\r\n\x05\x04\
    \x0c\x02\x05\x03\x12\x04\xb9\x02\x1b\x1c\n\x0c\n\x02\x04\r\x12\x06\xbc\
    \x02\0\xe8\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xbc\x02\x08\x0b\n\x0e\n\
    \x04\x04\r\x03\0\x12\x06\xbd\x02\x04\xcd\x02\x05\n\r\n\x05\x04\r\x03\0\
    \x01\x12\x04\xbd\x02\x0c\x15\n;\n\x06\x04\r\x03\0\x02\0\x12\x04\xbf\x02\
    \x08!\x1a+\x20Name\x20of\x20the\x20channel\x20group,\x20UTF-8\x20encoded\
    .\n\n\x0f\n\x07\x04\r\x03\0\x02\0\x04\x12\x04\xbf\x02\x08\x10\n\x0f\n\
    \x07\x04\r\x03\0\x02\0\x05\x12\x04\xbf\x02\x11\x17\n\x0f\n\x07\x04\r\x03\
    \0\x02\0\x01\x12\x04\xbf\x02\x18\x1c\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\
    \x12\x04\xbf\x02\x1f\x20\nS\n\x06\x04\r\x03\0\x02\x01\x12\x04\xc1\x02\
    \x085\x1aC\x20True\x20if\x20the\x20group\x20has\x20been\x20inherited\x20\
    from\x20the\x20parent\x20(Read\x20only).\n\n\x0f\n\x07\x04\r\x03\0\x02\
    \x01\x04\x12\x04\xc1\x02\x08\x10\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\
    \x04\xc1\x02\x11\x15\n\x0f\n\x07\x04\r\x03\0\x02\x01\x01\x12\x04\xc1\x02\
    \x16\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\x12\x04\xc1\x02\"#\n\x0f\n\
    \x07\x04\r\x03\0\x02\x01\x08\x12\x04\xc1\x02$4\n\x0f\n\x07\x04\r\x03\0\
    \x02\x01\x07\x12\x04\xc1\x02/3\n:\n\x06\x04\r\x03\0\x02\x02\x12\x04\xc3\
    \x02\x083\x1a*\x20True\x20if\x20the\x20group\x20members\x20are\x20inheri\
    ted.\n\n\x0f\n\x07\x04\r\x03\0\x02\x02\x04\x12\x04\xc3\x02\x08\x10\n\x0f\
    \n\x07\x04\r\x03\0\x02\x02\x05\x12\x04\xc3\x02\x11\x15\n\x0f\n\x07\x04\r\
    \x03\0\x02\x02\x01\x12\x04\xc3\x02\x16\x1d\n\x0f\n\x07\x04\r\x03\0\x02\
    \x02\x03\x12\x04\xc3\x02\x20!\n\x0f\n\x07\x04\r\x03\0\x02\x02\x08\x12\
    \x04\xc3\x02\"2\n\x0f\n\x07\x04\r\x03\0\x02\x02\x07\x12\x04\xc3\x02-1\nE\
    \n\x06\x04\r\x03\0\x02\x03\x12\x04\xc5\x02\x087\x1a5\x20True\x20if\x20th\
    e\x20group\x20can\x20be\x20inherited\x20by\x20sub\x20channels.\n\n\x0f\n\
    \x07\x04\r\x03\0\x02\x03\x04\x12\x04\xc5\x02\x08\x10\n\x0f\n\x07\x04\r\
    \x03\0\x02\x03\x05\x12\x04\xc5\x02\x11\x15\n\x0f\n\x07\x04\r\x03\0\x02\
    \x03\x01\x12\x04\xc5\x02\x16!\n\x0f\n\x07\x04\r\x03\0\x02\x03\x03\x12\
    \x04\xc5\x02$%\n\x0f\n\x07\x04\r\x03\0\x02\x03\x08\x12\x04\xc5\x02&6\n\
    \x0f\n\x07\x04\r\x03\0\x02\x03\x07\x12\x04\xc5\x0215\nQ\n\x06\x04\r\x03\
    \0\x02\x04\x12\x04\xc7\x02\x08\x20\x1aA\x20Users\x20explicitly\x20includ\
    ed\x20in\x20this\x20group,\x20identified\x20by\x20user_id.\n\n\x0f\n\x07\
    \x04\r\x03\0\x02\x04\x04\x12\x04\xc7\x02\x08\x10\n\x0f\n\x07\x04\r\x03\0\
    \x02\x04\x05\x12\x04\xc7\x02\x11\x17\n\x0f\n\x07\x04\r\x03\0\x02\x04\x01\
    \x12\x04\xc7\x02\x18\x1b\n\x0f\n\x07\x04\r\x03\0\x02\x04\x03\x12\x04\xc7\
    \x02\x1e\x1f\n\x83\x01\n\x06\x04\r\x03\0\x02\x05\x12\x04\xca\x02\x08#\
    \x1as\x20Users\x20explicitly\x20removed\x20from\x20this\x20group\x20in\
    \x20this\x20channel\x20if\x20the\x20group\n\x20has\x20been\x20inherited,\
    \x20identified\x20by\x20user_id.\n\n\x0f\n\x07\x04\r\x03\0\x02\x05\x04\
    \x12\x04\xca\x02\x08\x10\n\x0f\n\x07\x04\r\x03\0\x02\x05\x05\x12\x04\xca\
    \x02\x11\x17\n\x0f\n\x07\x04\r\x03\0\x02\x05\x01\x12\x04\xca\x02\x18\x1e\
    \n\x0f\n\x07\x04\r\x03\0\x02\x05\x03\x12\x04\xca\x02!\"\n9\n\x06\x04\r\
    \x03\0\x02\x06\x12\x04\xcc\x02\x08.\x1a)\x20Users\x20inherited,\x20ident\
    ified\x20by\x20user_id.\n\n\x0f\n\x07\x04\r\x03\0\x02\x06\x04\x12\x04\
    \xcc\x02\x08\x10\n\x0f\n\x07\x04\r\x03\0\x02\x06\x05\x12\x04\xcc\x02\x11\
    \x17\n\x0f\n\x07\x04\r\x03\0\x02\x06\x01\x12\x04\xcc\x02\x18)\n\x0f\n\
    \x07\x04\r\x03\0\x02\x06\x03\x12\x04\xcc\x02,-\n\x0e\n\x04\x04\r\x03\x01\
    \x12\x06\xce\x02\x04\xdd\x02\x05\n\r\n\x05\x04\r\x03\x01\x01\x12\x04\xce\
    \x02\x0c\x13\nB\n\x06\x04\r\x03\x01\x02\0\x12\x04\xd0\x02\x086\x1a2\x20T\
    rue\x20if\x20this\x20ACL\x20applies\x20to\x20the\x20current\x20channel.\
    \n\n\x0f\n\x07\x04\r\x03\x01\x02\0\x04\x12\x04\xd0\x02\x08\x10\n\x0f\n\
    \x07\x04\r\x03\x01\x02\0\x05\x12\x04\xd0\x02\x11\x15\n\x0f\n\x07\x04\r\
    \x03\x01\x02\0\x01\x12\x04\xd0\x02\x16\x20\n\x0f\n\x07\x04\r\x03\x01\x02\
    \0\x03\x12\x04\xd0\x02#$\n\x0f\n\x07\x04\r\x03\x01\x02\0\x08\x12\x04\xd0\
    \x02%5\n\x0f\n\x07\x04\r\x03\x01\x02\0\x07\x12\x04\xd0\x0204\n?\n\x06\
    \x04\r\x03\x01\x02\x01\x12\x04\xd2\x02\x086\x1a/\x20True\x20if\x20this\
    \x20ACL\x20applies\x20to\x20the\x20sub\x20channels.\n\n\x0f\n\x07\x04\r\
    \x03\x01\x02\x01\x04\x12\x04\xd2\x02\x08\x10\n\x0f\n\x07\x04\r\x03\x01\
    \x02\x01\x05\x12\x04\xd2\x02\x11\x15\n\x0f\n\x07\x04\r\x03\x01\x02\x01\
    \x01\x12\x04\xd2\x02\x16\x20\n\x0f\n\x07\x04\r\x03\x01\x02\x01\x03\x12\
    \x04\xd2\x02#$\n\x0f\n\x07\x04\r\x03\x01\x02\x01\x08\x12\x04\xd2\x02%5\n\
    \x0f\n\x07\x04\r\x03\x01\x02\x01\x07\x12\x04\xd2\x0204\nE\n\x06\x04\r\
    \x03\x01\x02\x02\x12\x04\xd4\x02\x085\x1a5\x20True\x20if\x20the\x20ACL\
    \x20has\x20been\x20inherited\x20from\x20the\x20parent.\n\n\x0f\n\x07\x04\
    \r\x03\x01\x02\x02\x04\x12\x04\xd4\x02\x08\x10\n\x0f\n\x07\x04\r\x03\x01\
    \x02\x02\x05\x12\x04\xd4\x02\x11\x15\n\x0f\n\x07\x04\r\x03\x01\x02\x02\
    \x01\x12\x04\xd4\x02\x16\x1f\n\x0f\n\x07\x04\r\x03\x01\x02\x02\x03\x12\
    \x04\xd4\x02\"#\n\x0f\n\x07\x04\r\x03\x01\x02\x02\x08\x12\x04\xd4\x02$4\
    \n\x0f\n\x07\x04\r\x03\x01\x02\x02\x07\x12\x04\xd4\x02/3\n>\n\x06\x04\r\
    \x03\x01\x02\x03\x12\x04\xd6\x02\x08$\x1a.\x20ID\x20of\x20the\x20user\
    \x20that\x20is\x20affected\x20by\x20this\x20ACL.\n\n\x0f\n\x07\x04\r\x03\
    \x01\x02\x03\x04\x12\x04\xd6\x02\x08\x10\n\x0f\n\x07\x04\r\x03\x01\x02\
    \x03\x05\x12\x04\xd6\x02\x11\x17\n\x0f\n\x07\x04\r\x03\x01\x02\x03\x01\
    \x12\x04\xd6\x02\x18\x1f\n\x0f\n\x07\x04\r\x03\x01\x02\x03\x03\x12\x04\
    \xd6\x02\"#\n?\n\x06\x04\r\x03\x01\x02\x04\x12\x04\xd8\x02\x08\"\x1a/\
    \x20ID\x20of\x20the\x20group\x20that\x20is\x20affected\x20by\x20this\x20\
    ACL.\n\n\x0f\n\x07\x04\r\x03\x01\x02\x04\x04\x12\x04\xd8\x02\x08\x10\n\
    \x0f\n\x07\x04\r\x03\x01\x02\x04\x05\x12\x04\xd8\x02\x11\x17\n\x0f\n\x07\
    \x04\r\x03\x01\x02\x04\x01\x12\x04\xd8\x02\x18\x1d\n\x0f\n\x07\x04\r\x03\
    \x01\x02\x04\x03\x12\x04\xd8\x02\x20!\nH\n\x06\x04\r\x03\x01\x02\x05\x12\
    \x04\xda\x02\x08\"\x1a8\x20Bit\x20flag\x20field\x20of\x20the\x20permissi\
    ons\x20granted\x20by\x20this\x20ACL.\n\n\x0f\n\x07\x04\r\x03\x01\x02\x05\
    \x04\x12\x04\xda\x02\x08\x10\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x05\x12\
    \x04\xda\x02\x11\x17\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x01\x12\x04\xda\
    \x02\x18\x1d\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x03\x12\x04\xda\x02\x20!\
    \nG\n\x06\x04\r\x03\x01\x02\x06\x12\x04\xdc\x02\x08!\x1a7\x20Bit\x20flag\
    \x20field\x20of\x20the\x20permissions\x20denied\x20by\x20this\x20ACL.\n\
    \n\x0f\n\x07\x04\r\x03\x01\x02\x06\x04\x12\x04\xdc\x02\x08\x10\n\x0f\n\
    \x07\x04\r\x03\x01\x02\x06\x05\x12\x04\xdc\x02\x11\x17\n\x0f\n\x07\x04\r\
    \x03\x01\x02\x06\x01\x12\x04\xdc\x02\x18\x1c\n\x0f\n\x07\x04\r\x03\x01\
    \x02\x06\x03\x12\x04\xdc\x02\x1f\x20\n?\n\x04\x04\r\x02\0\x12\x04\xdf\
    \x02\x04#\x1a1\x20Channel\x20ID\x20of\x20the\x20channel\x20this\x20messa\
    ge\x20affects.\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xdf\x02\x04\x0c\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\xdf\x02\r\x13\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xdf\x02\x14\x1e\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xdf\x02!\"\n?\n\
    \x04\x04\r\x02\x01\x12\x04\xe1\x02\x044\x1a1\x20True\x20if\x20the\x20cha\
    nnel\x20inherits\x20its\x20parent's\x20ACLs.\n\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xe1\x02\x04\x0c\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xe1\x02\
    \r\x11\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xe1\x02\x12\x1e\n\r\n\x05\x04\
    \r\x02\x01\x03\x12\x04\xe1\x02!\"\n\r\n\x05\x04\r\x02\x01\x08\x12\x04\
    \xe1\x02#3\n\r\n\x05\x04\r\x02\x01\x07\x12\x04\xe1\x02.2\n*\n\x04\x04\r\
    \x02\x02\x12\x04\xe3\x02\x04\"\x1a\x1c\x20User\x20group\x20specification\
    s.\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xe3\x02\x04\x0c\n\r\n\x05\x04\r\
    \x02\x02\x06\x12\x04\xe3\x02\r\x16\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\
    \xe3\x02\x17\x1d\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xe3\x02\x20!\n#\n\
    \x04\x04\r\x02\x03\x12\x04\xe5\x02\x04\x1e\x1a\x15\x20ACL\x20specificati\
    ons.\n\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xe5\x02\x04\x0c\n\r\n\x05\x04\
    \r\x02\x03\x06\x12\x04\xe5\x02\r\x14\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xe5\x02\x15\x19\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xe5\x02\x1c\x1d\nP\
    \n\x04\x04\r\x02\x04\x12\x04\xe7\x02\x04.\x1aB\x20True\x20if\x20the\x20m\
    essage\x20is\x20a\x20query\x20for\x20ACLs\x20instead\x20of\x20setting\
    \x20them.\n\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xe7\x02\x04\x0c\n\r\n\
    \x05\x04\r\x02\x04\x05\x12\x04\xe7\x02\r\x11\n\r\n\x05\x04\r\x02\x04\x01\
    \x12\x04\xe7\x02\x12\x17\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xe7\x02\x1a\
    \x1b\n\r\n\x05\x04\r\x02\x04\x08\x12\x04\xe7\x02\x1c-\n\r\n\x05\x04\r\
    \x02\x04\x07\x12\x04\xe7\x02',\n\xe3\x01\n\x02\x04\x0e\x12\x06\xed\x02\0\
    \xf2\x02\x01\x1a\xd4\x01\x20Client\x20may\x20use\x20this\x20message\x20t\
    o\x20refresh\x20its\x20registered\x20user\x20information.\x20The\n\x20cl\
    ient\x20should\x20fill\x20the\x20IDs\x20or\x20Names\x20of\x20the\x20user\
    s\x20it\x20wants\x20to\x20refresh.\x20The\n\x20server\x20fills\x20the\
    \x20missing\x20parts\x20and\x20sends\x20the\x20message\x20back.\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xed\x02\x08\x12\n\x19\n\x04\x04\x0e\x02\0\x12\
    \x04\xef\x02\x04\x1c\x1a\x0b\x20user_ids.\n\n\r\n\x05\x04\x0e\x02\0\x04\
    \x12\x04\xef\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xef\x02\r\
    \x13\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xef\x02\x14\x17\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\xef\x02\x1a\x1b\n4\n\x04\x04\x0e\x02\x01\x12\x04\
    \xf1\x02\x04\x1e\x1a&\x20User\x20names\x20in\x20the\x20same\x20order\x20\
    as\x20ids.\n\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xf1\x02\x04\x0c\n\r\n\
    \x05\x04\x0e\x02\x01\x05\x12\x04\xf1\x02\r\x13\n\r\n\x05\x04\x0e\x02\x01\
    \x01\x12\x04\xf1\x02\x14\x19\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xf1\
    \x02\x1c\x1d\n\xf4\x01\n\x02\x04\x0f\x12\x06\xf8\x02\0\xff\x02\x01\x1a\
    \xe5\x01\x20Used\x20to\x20initialize\x20and\x20resync\x20the\x20UDP\x20e\
    ncryption.\x20Either\x20side\x20may\x20request\x20a\n\x20resync\x20by\
    \x20sending\x20the\x20message\x20without\x20any\x20values\x20filled.\x20\
    The\x20resync\x20is\n\x20performed\x20by\x20sending\x20the\x20message\
    \x20with\x20only\x20the\x20client\x20or\x20server\x20nonce\n\x20filled.\
    \n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xf8\x02\x08\x12\n\x1f\n\x04\x04\x0f\
    \x02\0\x12\x04\xfa\x02\x04\x1b\x1a\x11\x20Encryption\x20key.\n\n\r\n\x05\
    \x04\x0f\x02\0\x04\x12\x04\xfa\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x05\
    \x12\x04\xfa\x02\r\x12\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xfa\x02\x13\
    \x16\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xfa\x02\x19\x1a\n\x1d\n\x04\x04\
    \x0f\x02\x01\x12\x04\xfc\x02\x04$\x1a\x0f\x20Client\x20nonce.\n\n\r\n\
    \x05\x04\x0f\x02\x01\x04\x12\x04\xfc\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\xfc\x02\r\x12\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xfc\
    \x02\x13\x1f\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xfc\x02\"#\n\x1d\n\
    \x04\x04\x0f\x02\x02\x12\x04\xfe\x02\x04$\x1a\x0f\x20Server\x20nonce.\n\
    \n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xfe\x02\x04\x0c\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\xfe\x02\r\x12\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\
    \xfe\x02\x13\x1f\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xfe\x02\"#\nN\n\
    \x02\x04\x10\x12\x06\x82\x03\0\x9b\x03\x01\x1a@\x20Used\x20to\x20add\x20\
    or\x20remove\x20custom\x20context\x20menu\x20item\x20on\x20client-side.\
    \n\n\x0b\n\x03\x04\x10\x01\x12\x04\x82\x03\x08\x1b\n\x0e\n\x04\x04\x10\
    \x04\0\x12\x06\x83\x03\x04\x8a\x03\x05\n\r\n\x05\x04\x10\x04\0\x01\x12\
    \x04\x83\x03\t\x10\n5\n\x06\x04\x10\x04\0\x02\0\x12\x04\x85\x03\x08\x16\
    \x1a%\x20Action\x20is\x20applicable\x20to\x20the\x20server.\n\n\x0f\n\
    \x07\x04\x10\x04\0\x02\0\x01\x12\x04\x85\x03\x08\x0e\n\x0f\n\x07\x04\x10\
    \x04\0\x02\0\x02\x12\x04\x85\x03\x11\x15\n.\n\x06\x04\x10\x04\0\x02\x01\
    \x12\x04\x87\x03\x08\x17\x1a\x1e\x20Action\x20can\x20target\x20a\x20Chan\
    nel.\n\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\x87\x03\x08\x0f\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x01\x02\x12\x04\x87\x03\x12\x16\n+\n\x06\
    \x04\x10\x04\0\x02\x02\x12\x04\x89\x03\x08\x14\x1a\x1b\x20Action\x20can\
    \x20target\x20a\x20User.\n\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x01\x12\x04\
    \x89\x03\x08\x0c\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x02\x12\x04\x89\x03\
    \x0f\x13\n\x0e\n\x04\x04\x10\x04\x01\x12\x06\x8b\x03\x04\x8e\x03\x05\n\r\
    \n\x05\x04\x10\x04\x01\x01\x12\x04\x8b\x03\t\x12\n\x0e\n\x06\x04\x10\x04\
    \x01\x02\0\x12\x04\x8c\x03\x08\x10\n\x0f\n\x07\x04\x10\x04\x01\x02\0\x01\
    \x12\x04\x8c\x03\x08\x0b\n\x0f\n\x07\x04\x10\x04\x01\x02\0\x02\x12\x04\
    \x8c\x03\x0e\x0f\n\x0e\n\x06\x04\x10\x04\x01\x02\x01\x12\x04\x8d\x03\x08\
    \x13\n\x0f\n\x07\x04\x10\x04\x01\x02\x01\x01\x12\x04\x8d\x03\x08\x0e\n\
    \x0f\n\x07\x04\x10\x04\x01\x02\x01\x02\x12\x04\x8d\x03\x11\x12\nH\n\x04\
    \x04\x10\x02\0\x12\x04\x90\x03\x04\x1f\x1a:\x20The\x20action\x20identifi\
    er.\x20Used\x20later\x20to\x20initiate\x20an\x20action.\n\n\r\n\x05\x04\
    \x10\x02\0\x04\x12\x04\x90\x03\x04\x0c\n\r\n\x05\x04\x10\x02\0\x05\x12\
    \x04\x90\x03\r\x13\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x90\x03\x14\x1a\n\
    \r\n\x05\x04\x10\x02\0\x03\x12\x04\x90\x03\x1d\x1e\n/\n\x04\x04\x10\x02\
    \x01\x12\x04\x92\x03\x04\x1d\x1a!\x20The\x20display\x20name\x20of\x20the\
    \x20action.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x92\x03\x04\x0c\n\r\
    \n\x05\x04\x10\x02\x01\x05\x12\x04\x92\x03\r\x13\n\r\n\x05\x04\x10\x02\
    \x01\x01\x12\x04\x92\x03\x14\x18\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\
    \x92\x03\x1b\x1c\n\x80\x01\n\x04\x04\x10\x02\x02\x12\x04\x95\x03\x04\x20\
    \x1ar\x20Context\x20bit\x20flags\x20defining\x20where\x20the\x20action\
    \x20should\x20be\x20displayed.\n\x20Flags\x20can\x20be\x20OR-ed\x20to\
    \x20combine\x20different\x20types.\n\n\r\n\x05\x04\x10\x02\x02\x04\x12\
    \x04\x95\x03\x04\x0c\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\x95\x03\r\x13\
    \n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x95\x03\x14\x1b\n\r\n\x05\x04\x10\
    \x02\x02\x03\x12\x04\x95\x03\x1e\x1f\n\xe8\x01\n\x04\x04\x10\x02\x03\x12\
    \x04\x9a\x03\x04%\x1a\xd9\x01\x20Choose\x20either\x20to\x20add\x20or\x20\
    to\x20remove\x20the\x20context\x20action.\n\x20Note:\x20This\x20field\
    \x20only\x20exists\x20after\x20Mumble\x201.2.4-beta1\x20release.\n\x20\
    \x20\x20\x20\x20\x20\x20The\x20message\x20will\x20be\x20recognized\x20as\
    \x20Add\x20regardless\x20of\x20this\x20field\n\x20\x20\x20\x20\x20\x20\
    \x20before\x20said\x20release.\n\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\
    \x9a\x03\x04\x0c\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\x9a\x03\r\x16\n\r\
    \n\x05\x04\x10\x02\x03\x01\x12\x04\x9a\x03\x17\x20\n\r\n\x05\x04\x10\x02\
    \x03\x03\x12\x04\x9a\x03#$\nN\n\x02\x04\x11\x12\x06\x9e\x03\0\xa5\x03\
    \x01\x1a@\x20Sent\x20by\x20the\x20client\x20when\x20it\x20wants\x20to\
    \x20initiate\x20a\x20Context\x20action.\n\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\x9e\x03\x08\x15\nF\n\x04\x04\x11\x02\0\x12\x04\xa0\x03\x04\x20\x1a8\
    \x20The\x20target\x20User\x20for\x20the\x20action,\x20identified\x20by\
    \x20session.\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xa0\x03\x04\x0c\n\r\n\
    \x05\x04\x11\x02\0\x05\x12\x04\xa0\x03\r\x13\n\r\n\x05\x04\x11\x02\0\x01\
    \x12\x04\xa0\x03\x14\x1b\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xa0\x03\x1e\
    \x1f\nL\n\x04\x04\x11\x02\x01\x12\x04\xa2\x03\x04#\x1a>\x20The\x20target\
    \x20Channel\x20for\x20the\x20action,\x20identified\x20by\x20channel_id.\
    \n\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xa2\x03\x04\x0c\n\r\n\x05\x04\
    \x11\x02\x01\x05\x12\x04\xa2\x03\r\x13\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xa2\x03\x14\x1e\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xa2\x03!\"\n3\
    \n\x04\x04\x11\x02\x02\x12\x04\xa4\x03\x04\x1f\x1a%\x20The\x20action\x20\
    that\x20should\x20be\x20executed.\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\
    \x04\xa4\x03\x04\x0c\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xa4\x03\r\x13\
    \n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xa4\x03\x14\x1a\n\r\n\x05\x04\x11\
    \x02\x02\x03\x12\x04\xa4\x03\x1d\x1e\n+\n\x02\x04\x12\x12\x06\xa8\x03\0\
    \xb3\x03\x01\x1a\x1d\x20Lists\x20the\x20registered\x20users.\n\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\xa8\x03\x08\x10\n\x0e\n\x04\x04\x12\x03\0\x12\
    \x06\xa9\x03\x04\xb0\x03\x05\n\r\n\x05\x04\x12\x03\0\x01\x12\x04\xa9\x03\
    \x0c\x10\n%\n\x06\x04\x12\x03\0\x02\0\x12\x04\xab\x03\x08$\x1a\x15\x20Re\
    gistered\x20user\x20ID.\n\n\x0f\n\x07\x04\x12\x03\0\x02\0\x04\x12\x04\
    \xab\x03\x08\x10\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\x12\x04\xab\x03\x11\
    \x17\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xab\x03\x18\x1f\n\x0f\n\
    \x07\x04\x12\x03\0\x02\0\x03\x12\x04\xab\x03\"#\n'\n\x06\x04\x12\x03\0\
    \x02\x01\x12\x04\xad\x03\x08!\x1a\x17\x20Registered\x20user\x20name.\n\n\
    \x0f\n\x07\x04\x12\x03\0\x02\x01\x04\x12\x04\xad\x03\x08\x10\n\x0f\n\x07\
    \x04\x12\x03\0\x02\x01\x05\x12\x04\xad\x03\x11\x17\n\x0f\n\x07\x04\x12\
    \x03\0\x02\x01\x01\x12\x04\xad\x03\x18\x1c\n\x0f\n\x07\x04\x12\x03\0\x02\
    \x01\x03\x12\x04\xad\x03\x1f\x20\n\x0e\n\x06\x04\x12\x03\0\x02\x02\x12\
    \x04\xae\x03\x08&\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x04\x12\x04\xae\x03\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x05\x12\x04\xae\x03\x11\x17\n\
    \x0f\n\x07\x04\x12\x03\0\x02\x02\x01\x12\x04\xae\x03\x18!\n\x0f\n\x07\
    \x04\x12\x03\0\x02\x02\x03\x12\x04\xae\x03$%\n\x0e\n\x06\x04\x12\x03\0\
    \x02\x03\x12\x04\xaf\x03\x08)\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x04\x12\
    \x04\xaf\x03\x08\x10\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x05\x12\x04\xaf\
    \x03\x11\x17\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x01\x12\x04\xaf\x03\x18$\
    \n\x0f\n\x07\x04\x12\x03\0\x02\x03\x03\x12\x04\xaf\x03'(\n+\n\x04\x04\
    \x12\x02\0\x12\x04\xb2\x03\x04\x1c\x1a\x1d\x20A\x20list\x20of\x20registe\
    red\x20users.\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xb2\x03\x04\x0c\n\r\
    \n\x05\x04\x12\x02\0\x06\x12\x04\xb2\x03\r\x11\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xb2\x03\x12\x17\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb2\x03\
    \x1a\x1b\n\xc1\x01\n\x02\x04\x13\x12\x06\xb9\x03\0\xcb\x03\x01\x1a\xb2\
    \x01\x20Sent\x20by\x20the\x20client\x20when\x20it\x20wants\x20to\x20regi\
    ster\x20or\x20clear\x20whisper\x20targets.\n\n\x20Note:\x20The\x20first\
    \x20available\x20target\x20ID\x20is\x201\x20as\x200\x20is\x20reserved\
    \x20for\x20normal\n\x20talking.\x20Maximum\x20target\x20ID\x20is\x2030.\
    \n\n\x0b\n\x03\x04\x13\x01\x12\x04\xb9\x03\x08\x13\n\x0e\n\x04\x04\x13\
    \x03\0\x12\x06\xba\x03\x04\xc6\x03\x05\n\r\n\x05\x04\x13\x03\0\x01\x12\
    \x04\xba\x03\x0c\x12\n5\n\x06\x04\x13\x03\0\x02\0\x12\x04\xbc\x03\x08$\
    \x1a%\x20Users\x20that\x20are\x20included\x20as\x20targets.\n\n\x0f\n\
    \x07\x04\x13\x03\0\x02\0\x04\x12\x04\xbc\x03\x08\x10\n\x0f\n\x07\x04\x13\
    \x03\0\x02\0\x05\x12\x04\xbc\x03\x11\x17\n\x0f\n\x07\x04\x13\x03\0\x02\0\
    \x01\x12\x04\xbc\x03\x18\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\
    \xbc\x03\"#\n7\n\x06\x04\x13\x03\0\x02\x01\x12\x04\xbe\x03\x08'\x1a'\x20\
    Channel\x20that\x20is\x20included\x20as\x20a\x20target.\n\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x01\x04\x12\x04\xbe\x03\x08\x10\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x01\x05\x12\x04\xbe\x03\x11\x17\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x01\x01\x12\x04\xbe\x03\x18\"\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\x12\
    \x04\xbe\x03%&\n9\n\x06\x04\x13\x03\0\x02\x02\x12\x04\xc0\x03\x08\"\x1a)\
    \x20ACL\x20group\x20that\x20is\x20included\x20as\x20a\x20target.\n\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\xc0\x03\x08\x10\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x02\x05\x12\x04\xc0\x03\x11\x17\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x02\x01\x12\x04\xc0\x03\x18\x1d\n\x0f\n\x07\x04\x13\x03\0\x02\x02\
    \x03\x12\x04\xc0\x03\x20!\nS\n\x06\x04\x13\x03\0\x02\x03\x12\x04\xc2\x03\
    \x082\x1aC\x20True\x20if\x20the\x20voice\x20should\x20follow\x20links\
    \x20from\x20the\x20specified\x20channel.\n\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x03\x04\x12\x04\xc2\x03\x08\x10\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x05\
    \x12\x04\xc2\x03\x11\x15\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x01\x12\x04\
    \xc2\x03\x16\x1b\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x03\x12\x04\xc2\x03\
    \x1e\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x08\x12\x04\xc2\x03\x201\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x03\x07\x12\x04\xc2\x03+0\n]\n\x06\x04\x13\
    \x03\0\x02\x04\x12\x04\xc5\x03\x085\x1aM\x20True\x20if\x20the\x20voice\
    \x20should\x20also\x20be\x20sent\x20to\x20children\x20of\x20the\x20speci\
    fic\n\x20channel.\n\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x04\x12\x04\xc5\
    \x03\x08\x10\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x05\x12\x04\xc5\x03\x11\
    \x15\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x01\x12\x04\xc5\x03\x16\x1e\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x04\x03\x12\x04\xc5\x03!\"\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x04\x08\x12\x04\xc5\x03#4\n\x0f\n\x07\x04\x13\x03\0\x02\x04\
    \x07\x12\x04\xc5\x03.3\n\x20\n\x04\x04\x13\x02\0\x12\x04\xc8\x03\x04\x1b\
    \x1a\x12\x20Voice\x20target\x20ID.\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\
    \xc8\x03\x04\x0c\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xc8\x03\r\x13\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xc8\x03\x14\x16\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xc8\x03\x19\x1a\n>\n\x04\x04\x13\x02\x01\x12\x04\xca\x03\
    \x04\x20\x1a0\x20The\x20receivers\x20that\x20this\x20voice\x20target\x20\
    includes.\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xca\x03\x04\x0c\n\r\n\
    \x05\x04\x13\x02\x01\x06\x12\x04\xca\x03\r\x13\n\r\n\x05\x04\x13\x02\x01\
    \x01\x12\x04\xca\x03\x14\x1b\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xca\
    \x03\x1e\x1f\n\xbb\x01\n\x02\x04\x14\x12\x06\xd0\x03\0\xd8\x03\x01\x1a\
    \xac\x01\x20Sent\x20by\x20the\x20client\x20when\x20it\x20wants\x20permis\
    sions\x20for\x20a\x20certain\x20channel.\x20Sent\x20by\n\x20the\x20serve\
    r\x20when\x20it\x20replies\x20to\x20the\x20query\x20or\x20wants\x20the\
    \x20user\x20to\x20resync\x20all\n\x20channel\x20permissions.\n\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xd0\x03\x08\x17\nP\n\x04\x04\x14\x02\0\x12\x04\
    \xd2\x03\x04#\x1aB\x20channel_id\x20of\x20the\x20channel\x20for\x20which\
    \x20the\x20permissions\x20are\x20queried.\n\n\r\n\x05\x04\x14\x02\0\x04\
    \x12\x04\xd2\x03\x04\x0c\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xd2\x03\r\
    \x13\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xd2\x03\x14\x1e\n\r\n\x05\x04\
    \x14\x02\0\x03\x12\x04\xd2\x03!\"\n$\n\x04\x04\x14\x02\x01\x12\x04\xd4\
    \x03\x04$\x1a\x16\x20Channel\x20permissions.\n\n\r\n\x05\x04\x14\x02\x01\
    \x04\x12\x04\xd4\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xd4\
    \x03\r\x13\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xd4\x03\x14\x1f\n\r\n\
    \x05\x04\x14\x02\x01\x03\x12\x04\xd4\x03\"#\nd\n\x04\x04\x14\x02\x02\x12\
    \x04\xd7\x03\x04.\x1aV\x20True\x20if\x20the\x20client\x20should\x20drop\
    \x20its\x20current\x20permission\x20information\x20for\x20all\n\x20chann\
    els.\n\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xd7\x03\x04\x0c\n\r\n\x05\
    \x04\x14\x02\x02\x05\x12\x04\xd7\x03\r\x11\n\r\n\x05\x04\x14\x02\x02\x01\
    \x12\x04\xd7\x03\x12\x17\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xd7\x03\
    \x1a\x1b\n\r\n\x05\x04\x14\x02\x02\x08\x12\x04\xd7\x03\x1c-\n\r\n\x05\
    \x04\x14\x02\x02\x07\x12\x04\xd7\x03',\n\xa5\x01\n\x02\x04\x15\x12\x06\
    \xdc\x03\0\xe4\x03\x01\x1a\x96\x01\x20Sent\x20by\x20the\x20server\x20to\
    \x20notify\x20the\x20users\x20of\x20the\x20version\x20of\x20the\x20CELT\
    \x20codec\x20they\n\x20should\x20use.\x20This\x20may\x20change\x20during\
    \x20the\x20connection\x20when\x20new\x20users\x20join.\n\n\x0b\n\x03\x04\
    \x15\x01\x12\x04\xdc\x03\x08\x14\n4\n\x04\x04\x15\x02\0\x12\x04\xde\x03\
    \x04\x1d\x1a&\x20The\x20version\x20of\x20the\x20CELT\x20Alpha\x20codec.\
    \n\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xde\x03\x04\x0c\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\xde\x03\r\x12\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xde\
    \x03\x13\x18\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xde\x03\x1b\x1c\n3\n\
    \x04\x04\x15\x02\x01\x12\x04\xe0\x03\x04\x1c\x1a%\x20The\x20version\x20o\
    f\x20the\x20CELT\x20Beta\x20codec.\n\n\r\n\x05\x04\x15\x02\x01\x04\x12\
    \x04\xe0\x03\x04\x0c\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xe0\x03\r\x12\
    \n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xe0\x03\x13\x17\n\r\n\x05\x04\x15\
    \x02\x01\x03\x12\x04\xe0\x03\x1a\x1b\n?\n\x04\x04\x15\x02\x02\x12\x04\
    \xe2\x03\x044\x1a1\x20True\x20if\x20the\x20user\x20should\x20prefer\x20A\
    lpha\x20over\x20Beta.\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xe2\x03\
    \x04\x0c\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xe2\x03\r\x11\n\r\n\x05\
    \x04\x15\x02\x02\x01\x12\x04\xe2\x03\x12\x1e\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\xe2\x03!\"\n\r\n\x05\x04\x15\x02\x02\x08\x12\x04\xe2\x03#3\
    \n\r\n\x05\x04\x15\x02\x02\x07\x12\x04\xe2\x03.2\n\x0c\n\x04\x04\x15\x02\
    \x03\x12\x04\xe3\x03\x04-\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xe3\x03\
    \x04\x0c\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xe3\x03\r\x11\n\r\n\x05\
    \x04\x15\x02\x03\x01\x12\x04\xe3\x03\x12\x16\n\r\n\x05\x04\x15\x02\x03\
    \x03\x12\x04\xe3\x03\x19\x1a\n\r\n\x05\x04\x15\x02\x03\x08\x12\x04\xe3\
    \x03\x1b,\n\r\n\x05\x04\x15\x02\x03\x07\x12\x04\xe3\x03&+\nN\n\x02\x04\
    \x16\x12\x06\xe7\x03\0\x9b\x04\x01\x1a@\x20Used\x20to\x20communicate\x20\
    user\x20stats\x20between\x20the\x20server\x20and\x20clients.\n\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xe7\x03\x08\x11\n\x0e\n\x04\x04\x16\x03\0\x12\
    \x06\xe8\x03\x04\xf1\x03\x05\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\xe8\x03\
    \x0c\x11\n6\n\x06\x04\x16\x03\0\x02\0\x12\x04\xea\x03\x08!\x1a&\x20The\
    \x20amount\x20of\x20good\x20packets\x20received.\n\n\x0f\n\x07\x04\x16\
    \x03\0\x02\0\x04\x12\x04\xea\x03\x08\x10\n\x0f\n\x07\x04\x16\x03\0\x02\0\
    \x05\x12\x04\xea\x03\x11\x17\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\
    \xea\x03\x18\x1c\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xea\x03\x1f\
    \x20\n6\n\x06\x04\x16\x03\0\x02\x01\x12\x04\xec\x03\x08!\x1a&\x20The\x20\
    amount\x20of\x20late\x20packets\x20received.\n\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x01\x04\x12\x04\xec\x03\x08\x10\n\x0f\n\x07\x04\x16\x03\0\x02\x01\
    \x05\x12\x04\xec\x03\x11\x17\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x01\x12\
    \x04\xec\x03\x18\x1c\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x03\x12\x04\xec\
    \x03\x1f\x20\n7\n\x06\x04\x16\x03\0\x02\x02\x12\x04\xee\x03\x08!\x1a'\
    \x20The\x20amount\x20of\x20packets\x20never\x20received.\n\n\x0f\n\x07\
    \x04\x16\x03\0\x02\x02\x04\x12\x04\xee\x03\x08\x10\n\x0f\n\x07\x04\x16\
    \x03\0\x02\x02\x05\x12\x04\xee\x03\x11\x17\n\x0f\n\x07\x04\x16\x03\0\x02\
    \x02\x01\x12\x04\xee\x03\x18\x1c\n\x0f\n\x07\x04\x16\x03\0\x02\x02\x03\
    \x12\x04\xee\x03\x1f\x20\n.\n\x06\x04\x16\x03\0\x02\x03\x12\x04\xf0\x03\
    \x08#\x1a\x1e\x20The\x20amount\x20of\x20nonce\x20resyncs.\n\n\x0f\n\x07\
    \x04\x16\x03\0\x02\x03\x04\x12\x04\xf0\x03\x08\x10\n\x0f\n\x07\x04\x16\
    \x03\0\x02\x03\x05\x12\x04\xf0\x03\x11\x17\n\x0f\n\x07\x04\x16\x03\0\x02\
    \x03\x01\x12\x04\xf0\x03\x18\x1e\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x03\
    \x12\x04\xf0\x03!\"\n+\n\x04\x04\x16\x02\0\x12\x04\xf4\x03\x04\x20\x1a\
    \x1d\x20User\x20whose\x20stats\x20these\x20are.\n\n\r\n\x05\x04\x16\x02\
    \0\x04\x12\x04\xf4\x03\x04\x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xf4\
    \x03\r\x13\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xf4\x03\x14\x1b\n\r\n\x05\
    \x04\x16\x02\0\x03\x12\x04\xf4\x03\x1e\x1f\nP\n\x04\x04\x16\x02\x01\x12\
    \x04\xf6\x03\x043\x1aB\x20True\x20if\x20the\x20message\x20contains\x20on\
    ly\x20mutable\x20stats\x20(packets,\x20ping).\n\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xf6\x03\x04\x0c\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xf6\x03\r\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xf6\x03\x12\x1c\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\xf6\x03\x1f\x20\n\r\n\x05\x04\x16\x02\
    \x01\x08\x12\x04\xf6\x03!2\n\r\n\x05\x04\x16\x02\x01\x07\x12\x04\xf6\x03\
    ,1\nR\n\x04\x04\x16\x02\x02\x12\x04\xf8\x03\x04$\x1aD\x20Full\x20user\
    \x20certificate\x20chain\x20of\x20the\x20user\x20certificate\x20in\x20DE\
    R\x20format.\n\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xf8\x03\x04\x0c\n\r\
    \n\x05\x04\x16\x02\x02\x05\x12\x04\xf8\x03\r\x12\n\r\n\x05\x04\x16\x02\
    \x02\x01\x12\x04\xf8\x03\x13\x1f\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\
    \xf8\x03\"#\nG\n\x04\x04\x16\x02\x03\x12\x04\xfa\x03\x04#\x1a9\x20Packet\
    \x20statistics\x20for\x20packets\x20received\x20from\x20the\x20client.\n\
    \n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\xfa\x03\x04\x0c\n\r\n\x05\x04\x16\
    \x02\x03\x06\x12\x04\xfa\x03\r\x12\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\
    \xfa\x03\x13\x1e\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xfa\x03!\"\nA\n\
    \x04\x04\x16\x02\x04\x12\x04\xfc\x03\x04#\x1a3\x20Packet\x20statistics\
    \x20for\x20packets\x20sent\x20by\x20the\x20server.\n\n\r\n\x05\x04\x16\
    \x02\x04\x04\x12\x04\xfc\x03\x04\x0c\n\r\n\x05\x04\x16\x02\x04\x06\x12\
    \x04\xfc\x03\r\x12\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\xfc\x03\x13\x1e\
    \n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xfc\x03!\"\n+\n\x04\x04\x16\x02\
    \x05\x12\x04\xff\x03\x04$\x1a\x1d\x20Amount\x20of\x20UDP\x20packets\x20s\
    ent.\n\n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\xff\x03\x04\x0c\n\r\n\x05\
    \x04\x16\x02\x05\x05\x12\x04\xff\x03\r\x13\n\r\n\x05\x04\x16\x02\x05\x01\
    \x12\x04\xff\x03\x14\x1f\n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\xff\x03\"\
    #\n+\n\x04\x04\x16\x02\x06\x12\x04\x81\x04\x04$\x1a\x1d\x20Amount\x20of\
    \x20TCP\x20packets\x20sent.\n\n\r\n\x05\x04\x16\x02\x06\x04\x12\x04\x81\
    \x04\x04\x0c\n\r\n\x05\x04\x16\x02\x06\x05\x12\x04\x81\x04\r\x13\n\r\n\
    \x05\x04\x16\x02\x06\x01\x12\x04\x81\x04\x14\x1f\n\r\n\x05\x04\x16\x02\
    \x06\x03\x12\x04\x81\x04\"#\n!\n\x04\x04\x16\x02\x07\x12\x04\x83\x04\x04\
    $\x1a\x13\x20UDP\x20ping\x20average.\n\n\r\n\x05\x04\x16\x02\x07\x04\x12\
    \x04\x83\x04\x04\x0c\n\r\n\x05\x04\x16\x02\x07\x05\x12\x04\x83\x04\r\x12\
    \n\r\n\x05\x04\x16\x02\x07\x01\x12\x04\x83\x04\x13\x1f\n\r\n\x05\x04\x16\
    \x02\x07\x03\x12\x04\x83\x04\"#\n\"\n\x04\x04\x16\x02\x08\x12\x04\x85\
    \x04\x04$\x1a\x14\x20UDP\x20ping\x20variance.\n\n\r\n\x05\x04\x16\x02\
    \x08\x04\x12\x04\x85\x04\x04\x0c\n\r\n\x05\x04\x16\x02\x08\x05\x12\x04\
    \x85\x04\r\x12\n\r\n\x05\x04\x16\x02\x08\x01\x12\x04\x85\x04\x13\x1f\n\r\
    \n\x05\x04\x16\x02\x08\x03\x12\x04\x85\x04\"#\n!\n\x04\x04\x16\x02\t\x12\
    \x04\x87\x04\x04%\x1a\x13\x20TCP\x20ping\x20average.\n\n\r\n\x05\x04\x16\
    \x02\t\x04\x12\x04\x87\x04\x04\x0c\n\r\n\x05\x04\x16\x02\t\x05\x12\x04\
    \x87\x04\r\x12\n\r\n\x05\x04\x16\x02\t\x01\x12\x04\x87\x04\x13\x1f\n\r\n\
    \x05\x04\x16\x02\t\x03\x12\x04\x87\x04\"$\n\"\n\x04\x04\x16\x02\n\x12\
    \x04\x89\x04\x04%\x1a\x14\x20TCP\x20ping\x20variance.\n\n\r\n\x05\x04\
    \x16\x02\n\x04\x12\x04\x89\x04\x04\x0c\n\r\n\x05\x04\x16\x02\n\x05\x12\
    \x04\x89\x04\r\x12\n\r\n\x05\x04\x16\x02\n\x01\x12\x04\x89\x04\x13\x1f\n\
    \r\n\x05\x04\x16\x02\n\x03\x12\x04\x89\x04\"$\n\x1f\n\x04\x04\x16\x02\
    \x0b\x12\x04\x8c\x04\x04\"\x1a\x11\x20Client\x20version.\n\n\r\n\x05\x04\
    \x16\x02\x0b\x04\x12\x04\x8c\x04\x04\x0c\n\r\n\x05\x04\x16\x02\x0b\x06\
    \x12\x04\x8c\x04\r\x14\n\r\n\x05\x04\x16\x02\x0b\x01\x12\x04\x8c\x04\x15\
    \x1c\n\r\n\x05\x04\x16\x02\x0b\x03\x12\x04\x8c\x04\x1f!\na\n\x04\x04\x16\
    \x02\x0c\x12\x04\x8f\x04\x04&\x1aS\x20A\x20list\x20of\x20CELT\x20bitstre\
    am\x20version\x20constants\x20supported\x20by\x20the\x20client\x20of\x20\
    this\n\x20user.\n\n\r\n\x05\x04\x16\x02\x0c\x04\x12\x04\x8f\x04\x04\x0c\
    \n\r\n\x05\x04\x16\x02\x0c\x05\x12\x04\x8f\x04\r\x12\n\r\n\x05\x04\x16\
    \x02\x0c\x01\x12\x04\x8f\x04\x13\x20\n\r\n\x05\x04\x16\x02\x0c\x03\x12\
    \x04\x8f\x04#%\n\"\n\x04\x04\x16\x02\r\x12\x04\x91\x04\x04\x20\x1a\x14\
    \x20Client\x20IP\x20address.\n\n\r\n\x05\x04\x16\x02\r\x04\x12\x04\x91\
    \x04\x04\x0c\n\r\n\x05\x04\x16\x02\r\x05\x12\x04\x91\x04\r\x12\n\r\n\x05\
    \x04\x16\x02\r\x01\x12\x04\x91\x04\x13\x1a\n\r\n\x05\x04\x16\x02\r\x03\
    \x12\x04\x91\x04\x1d\x1f\n.\n\x04\x04\x16\x02\x0e\x12\x04\x93\x04\x04#\
    \x1a\x20\x20Bandwidth\x20used\x20by\x20this\x20client.\n\n\r\n\x05\x04\
    \x16\x02\x0e\x04\x12\x04\x93\x04\x04\x0c\n\r\n\x05\x04\x16\x02\x0e\x05\
    \x12\x04\x93\x04\r\x13\n\r\n\x05\x04\x16\x02\x0e\x01\x12\x04\x93\x04\x14\
    \x1d\n\r\n\x05\x04\x16\x02\x0e\x03\x12\x04\x93\x04\x20\"\n$\n\x04\x04\
    \x16\x02\x0f\x12\x04\x95\x04\x04$\x1a\x16\x20Connection\x20duration.\n\n\
    \r\n\x05\x04\x16\x02\x0f\x04\x12\x04\x95\x04\x04\x0c\n\r\n\x05\x04\x16\
    \x02\x0f\x05\x12\x04\x95\x04\r\x13\n\r\n\x05\x04\x16\x02\x0f\x01\x12\x04\
    \x95\x04\x14\x1e\n\r\n\x05\x04\x16\x02\x0f\x03\x12\x04\x95\x04!#\n-\n\
    \x04\x04\x16\x02\x10\x12\x04\x97\x04\x04\"\x1a\x1f\x20Duration\x20since\
    \x20last\x20activity.\n\n\r\n\x05\x04\x16\x02\x10\x04\x12\x04\x97\x04\
    \x04\x0c\n\r\n\x05\x04\x16\x02\x10\x05\x12\x04\x97\x04\r\x13\n\r\n\x05\
    \x04\x16\x02\x10\x01\x12\x04\x97\x04\x14\x1c\n\r\n\x05\x04\x16\x02\x10\
    \x03\x12\x04\x97\x04\x1f!\n:\n\x04\x04\x16\x02\x11\x12\x04\x99\x04\x04<\
    \x1a,\x20True\x20if\x20the\x20user\x20has\x20a\x20strong\x20certificate.\
    \n\n\r\n\x05\x04\x16\x02\x11\x04\x12\x04\x99\x04\x04\x0c\n\r\n\x05\x04\
    \x16\x02\x11\x05\x12\x04\x99\x04\r\x11\n\r\n\x05\x04\x16\x02\x11\x01\x12\
    \x04\x99\x04\x12$\n\r\n\x05\x04\x16\x02\x11\x03\x12\x04\x99\x04')\n\r\n\
    \x05\x04\x16\x02\x11\x08\x12\x04\x99\x04*;\n\r\n\x05\x04\x16\x02\x11\x07\
    \x12\x04\x99\x045:\n\x0c\n\x04\x04\x16\x02\x12\x12\x04\x9a\x04\x04.\n\r\
    \n\x05\x04\x16\x02\x12\x04\x12\x04\x9a\x04\x04\x0c\n\r\n\x05\x04\x16\x02\
    \x12\x05\x12\x04\x9a\x04\r\x11\n\r\n\x05\x04\x16\x02\x12\x01\x12\x04\x9a\
    \x04\x12\x16\n\r\n\x05\x04\x16\x02\x12\x03\x12\x04\x9a\x04\x19\x1b\n\r\n\
    \x05\x04\x16\x02\x12\x08\x12\x04\x9a\x04\x1c-\n\r\n\x05\x04\x16\x02\x12\
    \x07\x12\x04\x9a\x04',\n\xb8\x04\n\x02\x04\x17\x12\x06\xa5\x04\0\xac\x04\
    \x01\x1a\xa9\x04\x20Used\x20by\x20the\x20client\x20to\x20request\x20bina\
    ry\x20data\x20from\x20the\x20server.\x20By\x20default\x20large\n\x20comm\
    ents\x20or\x20textures\x20are\x20not\x20sent\x20within\x20standard\x20me\
    ssages\x20but\x20instead\x20the\n\x20hash\x20is.\x20If\x20the\x20client\
    \x20does\x20not\x20recognize\x20the\x20hash\x20it\x20may\x20request\x20t\
    he\n\x20resource\x20when\x20it\x20needs\x20it.\x20The\x20client\x20does\
    \x20so\x20by\x20sending\x20a\x20RequestBlob\n\x20message\x20with\x20the\
    \x20correct\x20fields\x20filled\x20with\x20the\x20user\x20sessions\x20or\
    \x20channel_ids\n\x20it\x20wants\x20to\x20receive.\x20The\x20server\x20r\
    eplies\x20to\x20this\x20by\x20sending\x20a\x20new\n\x20UserState/Channel\
    State\x20message\x20with\x20the\x20resources\x20filled\x20even\x20if\x20\
    they\x20would\n\x20normally\x20be\x20transmitted\x20as\x20hashes.\n\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\xa5\x04\x08\x13\n=\n\x04\x04\x17\x02\0\
    \x12\x04\xa7\x04\x04(\x1a/\x20sessions\x20of\x20the\x20requested\x20User\
    State\x20textures.\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xa7\x04\x04\x0c\
    \n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xa7\x04\r\x13\n\r\n\x05\x04\x17\x02\
    \0\x01\x12\x04\xa7\x04\x14#\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xa7\x04&\
    '\n=\n\x04\x04\x17\x02\x01\x12\x04\xa9\x04\x04(\x1a/\x20sessions\x20of\
    \x20the\x20requested\x20UserState\x20comments.\n\n\r\n\x05\x04\x17\x02\
    \x01\x04\x12\x04\xa9\x04\x04\x0c\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\
    \xa9\x04\r\x13\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xa9\x04\x14#\n\r\n\
    \x05\x04\x17\x02\x01\x03\x12\x04\xa9\x04&'\nG\n\x04\x04\x17\x02\x02\x12\
    \x04\xab\x04\x04,\x1a9\x20channel_ids\x20of\x20the\x20requested\x20Chann\
    elState\x20descriptions.\n\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xab\x04\
    \x04\x0c\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xab\x04\r\x13\n\r\n\x05\
    \x04\x17\x02\x02\x01\x12\x04\xab\x04\x14'\n\r\n\x05\x04\x17\x02\x02\x03\
    \x12\x04\xab\x04*+\n`\n\x02\x04\x18\x12\x06\xb0\x04\0\xbd\x04\x01\x1aR\
    \x20Sent\x20by\x20the\x20server\x20when\x20it\x20informs\x20the\x20clien\
    ts\x20on\x20server\x20configuration\n\x20details.\n\n\x0b\n\x03\x04\x18\
    \x01\x12\x04\xb0\x04\x08\x14\n=\n\x04\x04\x18\x02\0\x12\x04\xb2\x04\x04&\
    \x1a/\x20The\x20maximum\x20bandwidth\x20the\x20clients\x20should\x20use.\
    \n\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xb2\x04\x04\x0c\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\xb2\x04\r\x13\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb2\
    \x04\x14!\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xb2\x04$%\n$\n\x04\x04\x18\
    \x02\x01\x12\x04\xb4\x04\x04%\x1a\x16\x20Server\x20welcome\x20text.\n\n\
    \r\n\x05\x04\x18\x02\x01\x04\x12\x04\xb4\x04\x04\x0c\n\r\n\x05\x04\x18\
    \x02\x01\x05\x12\x04\xb4\x04\r\x13\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\
    \xb4\x04\x14\x20\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xb4\x04#$\n/\n\
    \x04\x04\x18\x02\x02\x12\x04\xb6\x04\x04!\x1a!\x20True\x20if\x20the\x20s\
    erver\x20allows\x20HTML.\n\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xb6\x04\
    \x04\x0c\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xb6\x04\r\x11\n\r\n\x05\
    \x04\x18\x02\x02\x01\x12\x04\xb6\x04\x12\x1c\n\r\n\x05\x04\x18\x02\x02\
    \x03\x12\x04\xb6\x04\x1f\x20\n,\n\x04\x04\x18\x02\x03\x12\x04\xb8\x04\
    \x04'\x1a\x1e\x20Maximum\x20text\x20message\x20length.\n\n\r\n\x05\x04\
    \x18\x02\x03\x04\x12\x04\xb8\x04\x04\x0c\n\r\n\x05\x04\x18\x02\x03\x05\
    \x12\x04\xb8\x04\r\x13\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xb8\x04\x14\
    \"\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xb8\x04%&\n-\n\x04\x04\x18\x02\
    \x04\x12\x04\xba\x04\x04-\x1a\x1f\x20Maximum\x20image\x20message\x20leng\
    th.\n\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\xba\x04\x04\x0c\n\r\n\x05\
    \x04\x18\x02\x04\x05\x12\x04\xba\x04\r\x13\n\r\n\x05\x04\x18\x02\x04\x01\
    \x12\x04\xba\x04\x14(\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xba\x04+,\nB\
    \n\x04\x04\x18\x02\x05\x12\x04\xbc\x04\x04\"\x1a4\x20The\x20maximum\x20n\
    umber\x20of\x20users\x20allowed\x20on\x20the\x20server.\n\n\r\n\x05\x04\
    \x18\x02\x05\x04\x12\x04\xbc\x04\x04\x0c\n\r\n\x05\x04\x18\x02\x05\x05\
    \x12\x04\xbc\x04\r\x13\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xbc\x04\x14\
    \x1d\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xbc\x04\x20!\n\x82\x01\n\x02\
    \x04\x19\x12\x06\xc1\x04\0\xc9\x04\x01\x1at\x20Sent\x20by\x20the\x20serv\
    er\x20to\x20inform\x20the\x20clients\x20of\x20suggested\x20client\x20con\
    figuration\n\x20specified\x20by\x20the\x20server\x20administrator.\n\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xc1\x04\x08\x15\n)\n\x04\x04\x19\x02\0\
    \x12\x04\xc3\x04\x04\x20\x1a\x1b\x20Suggested\x20client\x20version.\n\n\
    \r\n\x05\x04\x19\x02\0\x04\x12\x04\xc3\x04\x04\x0c\n\r\n\x05\x04\x19\x02\
    \0\x05\x12\x04\xc3\x04\r\x13\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xc3\x04\
    \x14\x1b\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xc3\x04\x1e\x1f\n_\n\x04\
    \x04\x19\x02\x01\x12\x04\xc6\x04\x04!\x1aQ\x20True\x20if\x20the\x20admin\
    istrator\x20suggests\x20positional\x20audio\x20to\x20be\x20used\x20on\
    \x20this\n\x20server.\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xc6\x04\
    \x04\x0c\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xc6\x04\r\x11\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xc6\x04\x12\x1c\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xc6\x04\x1f\x20\nZ\n\x04\x04\x19\x02\x02\x12\x04\xc8\x04\
    \x04#\x1aL\x20True\x20if\x20the\x20administrator\x20suggests\x20push\x20\
    to\x20talk\x20to\x20be\x20used\x20on\x20this\x20server.\n\n\r\n\x05\x04\
    \x19\x02\x02\x04\x12\x04\xc8\x04\x04\x0c\n\r\n\x05\x04\x19\x02\x02\x05\
    \x12\x04\xc8\x04\r\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xc8\x04\x12\
    \x1e\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xc8\x04!\"\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
